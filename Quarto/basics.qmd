---
project:
  type: website
  output-dir: docs
title: "基礎"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
format:
  html:
    toc: true
    toc-title: 目次
    toc_float: true
    toc-depth: 4
    number-sections: true
    theme: simplex
    mermaid:
      theme: neutral
lang: ja
---

今回は，前回の練習問題の解答について解説しつつ，Rの基礎を学びます。
とくにデータの型と構造について理解しておかなければなりません。

Rを使うとき，常に，「このコードを実行するとこうなるはずだ」と予想してください。
予想通りの結果が得られた場合，自分の予想は正しかったことが確かめられます。
予想とは異なる結果が得られた場合，2つの原因が考えられます。

1. 予想の元となった自分の考えが間違っていた。
1. コードが間違っている。

どちらが原因で予想と異なる結果が得られたかを考えてください。
前者の場合は自分の考えを改める必要があります。
Rの学習は，この予想と結果を合わせていく作業です。
常に，予想した結果が得られなければなりません。


## データの型

データの型には，数値，文字列，ファクター（因子），論理値があります。
以下のどれかのコマンドを使って，そのデータの型を知ることができます。
```{r}
#| eval: false
typeof()
mode()
class()
```
ただし，常に意識するというよりは，エラーの原因追及（バグフィックス）時に必要な知識です。
このため，自分が書いたスクリプトにバグが入らないようにしたいなら，このデータの型を意識しておかなければなりません。
データの型には次の種類があります。

1. 実数
1. 整数
1. 文字列
1. ファクター
1. 論理値

### 数値

実数と整数はいずれも数値で，区別しなくても困りません。
数値は計算できます。
任意のオブジェクトが数値かどうかを判定したいときは，`is.double()` または `is.numeric()` を用います。
```{r}
x <- 10
is.double(x)
# is.numeric(x)
```
返り値の `TRUE` は真という意味で，判定（知りたいこと）が真のときに `TRUE` が返ってきます。

Rではデフォルトで数値は実数として扱われます。
数字を扱うにあたって，それ以上のことを考える必要はありません。
もし整数として明示的に扱いたい場合は，次の関係を知っておいてください。
```{r}
x <- 10
is.integer(x)
x <- 10L
is.integer(x)
x <- as.integer(10)
is.integer(x)
```
また，整数は整数として意識的に維持しなければ，容易に実数に変化します。
```{r}
10L + 2; is.integer(10L + 2)
10L + 2L; is.integer(10L + 2L)
```

### 文字列

文字列は文字として表現されるもので，`""` で括って表記します。
```{r}
c("a", "あ", 'b')
```
多くの場合，`""` は `''` で代替できます。
ただし，Rの返り値は必ず `""` で括られますので，`''` ではなく `""` を使うようにしてください。
```{r}
c("a", "あ", "b")
```

文字列の中に `"` を入れたい場合に `''` を使うとよいです。
```{r}
x <- '"あ"'
x
```
返り値がおかしいですね。
いや，これでいいのです。
`\` のことを**エスケープシーケンス**と呼びます。

エスケープシーケンスを使うと，文字列は常に `""` で括れます。
```{r}
x <- "\"あ\""
x
```

文字列をくっつける関数に `paste()` があります。
次のように使います。
```{r}
x <- "愛媛"
y <- "県"
paste(x, y)
```
デフォルトでは結合部分に半角スペースが入ります。
結合部分に入れる文字は，引数 `sep` で指定します。
何も入れたくない場合は，次のようにします。
```{r}
paste(x, y, sep = "")
```

数値を文字列に変換する場合は，`as.character()` を使います。
ただし，`paste()` の方が便利なため，`paste()` を頻繁に使うことになるでしょう。
例えば次のようにします。
```{r}
paste(2000:2010, "年", sep = "")
```
`paste()` は文字列を繋げる関数です。
引数には文字列を取りますので，引数に数値がある場合は，勝手に文字列に変換されます。

### ファクター

ファクターは見た目は文字列ですが，以下の特徴があります。

- 取り得る値の数が有限である。
- グループ分けに使える。
- 値に順番のようなものがある。

例えば，学生の成績は「秀」「優」「良」「可」「不可」で表現されます。
あるいは，「S」「A」「B」「C」「D」といった表現もあります。
これらの文字列には順番があります。
「秀」は「優」より上，「優」は「良」より上です。

また，「愛媛県」は文字列で，一見順番は関係なさそうですが，都道府県コードというものが割り振られており，都道府県別に並べるとき，愛媛県は38番目に表示するというルールがあります。
「北海道」が01で，「沖縄県」が47です。
他に，アンケート調査の選択のある問に対する解答として，「強くそう思う」「ややそう思う」「どちらでもない」「あまりそう思わない」「まったくそう思わない」といったデータがあり得ます。

こうしたデータを扱う場合，ファクターを文字列として考えていると，思い通りの表示にならなかったり，処理できずエラーが返ってくることがあります。

次のデータがあったとします。
```{r}
grade <- c("優", "良", "可", "良", "良", "不可", "秀", "優", "可", "良")
grade
```
この変数 `grade` に順番のようなものを持たせるためには，次のようにします。
```{r}
grade2 <- factor(grade, levels = c("不可", "可", "良", "優", "秀"))
grade2
```
ファクターの返り値に順番が `Levels` として表記されます。
この `Levels` はファクターに付けられたラベルであり，次のコマンドで取り出せます。
```{r}
levels(grade2)
```
ファクターのラベルを変更すれば，ファクターの各要素の値も変わります。
```{r}
levels(grade2) <- c("D", "C", "B", "A", "S")
grade2
```
ファクターを文字列に変換すれば，ラベル（順番の情報）は失われます。
```{r}
as.character(grade2)
```

上述の説明は**順番のようなもの**の存在を暗黙裏に扱っており，通常の使用ではこれで問題ありません。
もし明示的に**順番**を扱いたい場合は，次のようにする必要があります。
```{r}
factor(grade, levels = c("不可", "可", "良", "優", "秀"), ordered = TRUE)
```
また，上述のアンケート調査の例では，実際は，ファクターではなく，数値に変換して分析することもあります。
```{r}
x <- factor(grade, levels = c("不可", "可", "良", "優", "秀"))
as.double(x)
```

### 論理値

オブジェクトの状態を表すものに，`TRUE` と `FALSE` があります。
日本語では，`TRUE` は真で，`FALSE` で偽と表現します。
これまで関数の引数として登場しました。

`TRUE` は `T` と省略でき，`FALSE` は `F` と省略できることを知っておいてください。
ただし，自分では `T` や `F` を使わないでください。
複雑なコードのときに，`T` や `F` よりも，`TRUE` や `FALSE` の方が分かりやすいからです。
もしどこかで`T` や `F` を見かけたら，頭の中でそれぞれ `TRUE` と `FALSE` に置き換えてください。
なお，`True` や `true` ではなく，必ず大文字を使ってください。

論理値は，真偽を確かめたいときに関数の返り値として用いられます。
このとき，論理値が計算できることを知っておくと役に立つ場面がある。
```{r}
x <- rep(TRUE, 10)
x
sum(x)
```
この例のように，`TRUE` のベクトルをわざわざ生成することは実際はあまりありませんが，比較演算子を用いた判定の返り値を計算に利用することはよくあります。
このとき，`sum()` は `TRUE` の数に一致します。
つまり，`TRUE` の数を数えていると理解してもよいです。
実際には，R内部で `TRUE` は数値の `1` に変換され，`FALSE` は数値の `0` に変換された後，`sum()` が適用されています。


## データの構造

データの構造には以下の種類のものがあります。

1. ベクトル
1. 行列
1. データフレーム
1. リスト

### ベクトル

ベクトルは，`c()` で作成します。
```{r}
c(10, 12, 15, 20)
```
`seq()` などの関数のように，返り値がベクトルとなるものもあります。

ベクトルの四則演算はベクトルを返します。
```{r}
c(10, 12, 15, 20) * 5
```
列ベクトルか行ベクトルかはあまり気にする必要はありません。
ベクトルの転置は次のようにします。
```{r}
x <- 1990:2020
x
t(x)
```
このことから，`x` と `x` を転置した `t(x)` は違うことが分かります。

ベクトルは数値である必要はなく，文字列のベクトルも作成できます。
```{r}
c("テニス", "バレーボール", "野球", "サッカー")
```
ただし，ベクトルの各要素の型は同じでなければなりません。
例えば，数値と文字列を混ぜた場合，そのベクトルは文字列になります。
```{r}
#| error: true
x <- c(1, "テニス", 3)
x[1] + x[3]
```
文字列は，たとえ見た目が数値であったとしても，計算できません。
文字列は必ず `""` で括られています。
```{r}
x
```

ただし，文字列の中が数値の場合，その文字列は数値に変換できます。
文字列を数値に変換する場合は，`as.double()` を用います。
```{r}
as.double(x[1]) + as.double(x[3])
```
次のように，`as.numeric()` でも同じ結果が得られますが，文字列を数値に変換する場合，`as.double()` を使う方が（おそらく）正当なやり方です。
```{r}
as.numeric(x[1]) + as.numeric(x[3])
```

#### 欠損値

データがない部分のことを欠損値と言います。
数値の欠損値は `NA` で表します。
例えば，アンケート調査を実施して，ある回答者がある問の選択問題の解答をしていない場合，そこに `-` を入力してはいけません。
そこには，何も入力しないのが正しいデータ作成の方法です。
Microsoft Excelでデータ入力する場合は，そのセルには何も入力せずに次の入力に移ってください。
ただし，Rでデータ作成する場合，次のようにするとエラーが返ってきます。
```{r}
#| eval: false
c(1, 2, , 4, 5)
```
このため，欠損値には `NA` と書いてください。
```{r}
#| eval: false
c(1, 2, NA, 4, 5)
```
CSVファイルなどをRで読み込むときに欠損値があると，その部分がデフォルトでは `NA` に置き換わります。
ここで，次のようにするとエラーが返ってきます。
```{r}
#| eval: false
c(1, 2, -, 4, 5)
```
また，次のようにすると全体が文字列になります。
```{r}
#| eval: false
c(1, 2, "-", 4, 5)
```

一方，アンケート調査で，文章で回答してもらう問に対して無回答だった場合，そこに `""` を入力してください。
Microsoft Excelでデータ入力する場合は，そのセルには何も入力せずに次の入力に移ってください。
CSVファイルなどをRで読み込むときに欠損値があると，その部分がデフォルトでは `""` に置き換わります。
```{r}
#| eval: false
c("テニスが好き", "バレーボールをやってた", NA, "野球が苦手", "サッカーが得意")
```
これだとエラーは返ってきませんが，あまりよい方法ではありません。
この場合，次のようにしてください。
```{r}
#| eval: false
c("テニスが好き", "バレーボールをやってた", "", "野球が苦手", "サッカーが得意")
```

`NA` に似たものに `NULL` があります。
`NULL` はデータの欠損値には使いません。
`NULL` には例えば次のような使い方があります。
```{r}
#| eval: false
x <- NULL
```

### 名前付きベクトル

名前付きベクトルというものがあります。
辞書のような働きをします。

あまり使わないので，ここでは説明を省略します。

### 行列

Rは行列計算が高速であることが特徴のひとつです。
また，ここには書きませんが，行列を用いた数式の表記は簡潔です。

行列は以下のようにして作成します。
```{r}
matrix(1:12, nrow = 4)
```
`nrow` は行の数です。
行列の要素の数は，`nrow` の値で割り切れなければなりません。
列の数 `ncol` を指定しても構いません。

行列の外側の `[]`で囲まれた部分に注目してください。
`[]` と `,` と数字によって，そこが行列の何行目か，あるいは，何列目かが分かります。
`[行, 列]` という関係になっています。

行列はMicrosoft Excelでよく見る表に似ていますが，そうではなく，数学で出てくる行列そのものだと理解してください。
行列の要素は `[]` を用いて取り出します。
例えば，1行2列の要素は次のようにして取り出します。
```{r}
x <- matrix(1:12, nrow = 4)
x[1, 2]
```
行は次のようにして取り出します。
```{r}
x[2, ]
```
列は次のようにして取り出します。
```{r}
x[, 3]
```
この法則に従って，スペースを入れることを忘れないようにしてください（スペースを入れなくてもエラーは出ません）。

#### Tips

行列はベクトルを折り畳んだようなものであると理解しておくと役に立つことがあります。
次の結果を比較して，行列がベクトルであることを理解してください。
```{r}
matrix(1:12, nrow = 4)[5]
matrix(1:12, nrow = 4, byrow = TRUE)[5]
```
ただし，通常のデータ分析で行列を扱う機会は少ないかもしれません。
次のコマンドが `FALSE` を返すように，厳密にはベクトルではありません。
```{r}
is.vector(matrix(1:12, nrow = 4))
```
しかし，ベクトルであるかのように動作することがあります。

### データフレーム

データフレームはMicrosoft Excelでよく見る表に似ており，そのようなものだと理解してください。
`read.csv()` で読み込んだオブジェクトは，データフレームです。

データフレームには行と列が存在する点では，行列に似ています。
しかしながら，行列とは違い，各列を異なる型にすることができることから，行列よりも柔軟なデータ構造となります。
それぞれの列は同じ型でなければなりません。

Rには最初から多くのデータセットが使える状態になっています。
サンプルとしてよく使われるデータセットに `iris` があります。
`iris` の中身は，`iris` と入力するだけで表示されます。
```{r}
iris
```
`iris` は変数であり，次のコマンドで確かめられるように，データフレームです。
```{r}
is.data.frame(iris)
```
データフレームの全体を表示させることなく，データフレームの構造を知りたいときは，最初の数行を表示させるコマンドを使うのが便利です。
```{r}
head(iris)
```
同じように，最後の数行を表示させることもできます。
```{r}
tail(iris)
```
途中の行を表示させたい場合は，行番号を指定します。
```{r}
iris[100:105, ]
```
データフレームの構造を知りたい場合は，次のようにします。
```{r}
str(iris)
```
データフレームの列ごとにデータの型が表示されることが分かります。
行の数と列の数は次のコマンドで取得できる。
```{r}
dim(iris)
```

#### データフレームの列

データフレームそのものを分析に使うこともできますが，必要な列を取り出して，分析に使うのが一般的です。
そこで，データフレームの列を取り出す方法をいくつか説明します。
なお，データフレームの進化したものに，[tibble](https://tibble.tidyverse.org/){target="_blank"} があります。
tibbleはデータフレームとほとんど同じように扱えますが，データフレームとは挙動が若干異なりますので，違うものと考えてください。
ちなみに，`read_excel()` で読み込んだオブジェクトは，tibbleです。
tibbleは [Tidyverse](https://www.tidyverse.org/){target="_blank"} の一部分（最も重要な部分）を構成します。

データフレームの列を取り出す場合，左から何列目であるかを数値で指定することができます。
次のコマンドにより，データフレームの列をベクトルとして取り出すことができます。
```{r}
iris[, 1]
```
返り値をデータフレームとして保ちたければ，次のようにします。
```{r}
iris[1]
```
次のようにすると，左から1列目をベクトルとして取り出せます。
```{r}
iris[[1]]
```
このことから，`iris[, 1]` と `iris[[1]]` は同じ結果が得られることが分かります。

データフレームの左から何列目かという情報は，対話的にRを使う場合は便利なときもありますが，データフレームの構造を正確に把握しておかなければならず，またデータフレームの列が多くなった場合，何列目かをわざわざ数えなければなりません。
こうした作業は面倒だということもありますが，それ以上に，間違う可能性があります。
列を取り出す際，データフレームの左から何列目かという情報ではなく，列名で指定する方が間違いが少なくなるでしょう。
`iris` の `Sepal.Length` 列を取り出したい場合は，次のように `$` で繋ぎます。
```{r}
iris$Sepal.Length
```
列名が日本語の場合など，次のようにしなければエラーが返ってくることがあります。
```{r}
#| eval: false
iris$`Sepal.Length`
```
日本語の他にも，列名に `()` が使われている場合は，`` で括らなければエラーが返ってきます。
返り値をデータフレームとして保ちたければ，次のようにします。
```{r}
iris["Sepal.Length"]
```
このとき，`""` をつけなければエラーが返ってきます。
ここで，`""` の中は文字列として扱われるため，`` で括る必要はありません。
```{r}
#| error: true
iris[Sepal.Length]
```
このとき，`Sepal.Length` という名前の変数（オブジェクト）を探しに行き，それがないためエラーを返しています。
次のようにすると，ベクトルとして取り出せます。
```{r}
iris[["Sepal.Length"]]
```

ここで，列名を知るにはどうすればよいでしょうか。
`str()` で知ることができますが，`str()` だと情報が多いです。
データフレームの列名のみを得るには，次のコマンドを用います。
```{r}
names(iris)
```
これは次のようにしても同じです。
```{r}
colnames(iris)
```

次に，複数の列を取り出してみます。
`iris` の `Sepal.Length` 列と `Sepal.Width` 列を取り出すには，次のようにします。
```{r}
iris[c("Sepal.Length", "Sepal.Width")]
```
データフレームから複数列を取り出す場合，返り値はベクトルではなく，必ずデータフレームになります。
このため，`$` や `[[]]` は使えません。

ちなみに，以下のような表記法は，返り値としてベクトルが欲しい場合にもデータフレームが欲しい場合にも使えるので，便利です。
しかしながら，tibbleでこの方法は使えないため，残念ながら，こうした表記法は過去のものとなりました。
```{r}
#| eval: false
iris[, "Sepal.Length"]
iris[, "Sepal.Length", drop = FALSE]
iris[, c("Sepal.Length", "Sepal.Width")]
```

#### データフレームの列

データフレームは，`data.frame()` で作成します。
データフレーム作成時に注意すべきことは，各列の長さを合わせるということです。
各列の長さが揃わないときは，短い列を繰り返します。
この繰り返しが整数倍でない場合，エラーが返ってきます。
```{r}
#| eval: false
data.frame(year = 1991:2020, value1 = 1:30, value2 = NA, value3 = c("東", "西", "南"), value4 = 1:5)
```

### リスト

リストはさまざまな変数を入れることのできる，引き出しだと説明されることがあります。
さまざまな変数をリストに入れることができます。
データフレームのように，各要素の数を揃える必要はありません。
Pythonでいう辞書のようなものです。

リストはさまざまな形を取りますが，実践的には，複数のデータフレームを要素とできる点が便利です。
```{r}
#| eval: false
x <- list()
```

また，関数の返り値がリストとなることがあります。
例えば，データフレームをある列（ファクター）に従って分割したい場合，`split()` を用います。
```{r}
x <- split(iris, iris$Species)
x[[1]]
x[[names(x)[2]]]
```


## 特殊記号

### コメント

`#` で始まる行は**コメント**です。
行の途中に `#` がある場合は，そこから右，改行までの文字がコメントとみなされます。
Rはコメントを無視します。
コメントは人間が読んで理解できるようなことを書くのに重宝します。
Rはコメントを無視するため，何を書いても構いません。

[ファイル操作](./file_manipulation.html){target="_blank"} のコードでは，Windowsの場合とmacOSの場合を例示するのに，注釈としてコマンドの右に `#` を付けて説明しました。
このような使い方と同時に，macOSの場合を示した2行目は行頭にも `#` を付けています。
これは，この2行を実行することはない（実行してはいけない）ため，このような記述にしています。
macOSの人は `#` の右側のみをコピーしてください。
このように排他的であることを明示するために，コメントを使うこともあります。
他には，「このコードは一部の人のみ実行してください」や「このコードは実行しなくてもよい」といった意味で使用することもあります。

### セミコロン

通常，Rでは1行に複数のコマンドを書きません。
ただし，1行に複数のコマンドを書くこともできます。
何らかの理由により，1行に複数のコマンドを書きたい場合は，次のように `;` で繋げます。
```{r}
x <- 1:100; sum(x)
```
ただし，こうしたからといって処理速度が速くなることはありません。

セミコロンを使って書くと，コマンドと返り値の順番に変化がもたらされます。
```{r}
sum(x)
mean(x)
```
セミコロンのない場合とある場合とで，コマンドと返り値が表示される順番に違いがあることに注目してください。
```{r}
sum(x); mean(x)
```
返り値がまとまってほしいときに便利ですが，そうなってほしいことは滅多にありません。

### 評価と同時に返り値を表示

コマンドを実行して，返り値を得ることを評価と呼びます。
このとき，同時に，その返り値を表示したい場合，コマンド全体を `()` で括ります。
```{r}
(x <- 10)
```
関数の `()` とは異なり，全体を `()` で括ります。
これは次のようなコマンドを実行するのと同じことです。
```{r}
x <- 10
x
```
このように冗長に書くよりも，`()` を使った方が分かりやすいことがたまにあります。


## 入門書

奥村先生による [統計・データ解析](https://okumuralab.org/~okumura/stat/){target="_blank"} は大変参考になります。
時間をかけてじっくり読んむとともに，自分のパソコンで同じようにできるか確かめてください。

また，Posit Cloud にある [Posit Primers](https://posit.cloud/learn/primers){target="_blank"} は時間をかけて読む価値がありそうです。

### チートシート

[Posit Cheat Sheets](https://posit.cloud/learn/cheat-sheets){target="_blank"}

チートシートの日本語訳がここからダウンロードできます（ページ右側の Downloadボタンをクリック）。

- [rstudio/cheatsheets](https://github.com/rstudio/cheatsheets/tree/main/translations/japanese){target="_blank"}


## 練習問題

1. 次のデータフレーム `z` があるとする。
```{r}
#| eval: false
x <- 1990:2010
y <- seq(5000, 5040, 2)
z <- data.frame(year = x, value = y)
```
2000年代の値（ `value` 列）の平均を求めなさい。

2. [CSV Files](https://people.sc.fsu.edu/~jburkardt/data/csv/csv.html){target="_blank"}から任意のCSVファイルをダウンロードして，R上の変数 `test` に読み込みなさい。また，正しく読み込めたかを確かめなさい。
  + ヒント：CSVファイルを読み込む関数は，`read.csv()` です。

3. [政府統計の総合窓口（e-Stat）](https://www.e-stat.go.jp){target="_blank"}から任意のExcelファイルをダウンロードして，R上の変数 `excercise` に読み込みなさい。また，正しく読み込めたかを確かめなさい。

4. 気象庁の次のWebサイトからCSVファイルをダウンロードして，変数 `temp` に読み込んだ後，世界全体の年平均気温偏差の最大値と最小値を求めなさい。
  - [世界の年平均気温偏差（℃）](https://www.data.jma.go.jp/cpdinfo/temp/list/an_wld.html){target="_blank"}
