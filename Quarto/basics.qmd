---
project:
  type: website
  output-dir: docs
title: "基礎"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
format:
  html:
    toc: true
    toc-title: 目次
    toc_float: true
    toc-depth: 4
    number-sections: true
    theme: simplex
    mermaid:
      theme: neutral
lang: ja
---

今回は，前回の練習問題の解答について解説しつつ，Rの基礎を学びます。
とくにRのコンソールがいまどこにいるかを意識していないと，ファイルの読み書きに支障を来します。
また，変数の型について知っておかなければなりません。


## ファイル操作

まず，[CSV Files](https://people.sc.fsu.edu/~jburkardt/data/csv/csv.html){target="_blank"} から，任意のCSVファイルをダウンロードします。
例えば，`addresses.csv`をダウンロードした場合，次のコマンドで読み込めます。
```{r}
#| eval: false
read.csv("addresses.csv")
```
`read.csv("")` にある2つの `"` の間に，ダウンロードしたファイルの名前を入れます。
拡張子は省略してはいけません。
もし拡張子を非表示にするようにパソコンが設定されている場合は，**必ず**表示する設定に変更してください。

![Windowsの拡張子表示](./Windows_extension.png)

上のコマンドを実行したとき，ファイルが見つからないというエラーが返ってくる場合，対処方法は2つあります。

1. ダウンロードしたファイルを作業ディレクトリ（working directory）に移動する。
1. ダウンロードしたファイルへの絶対パスを指定する。

### ディレクトリ構造とファイル管理の基礎

そもそもの話として，[CUI](https://ja.wikipedia.org/wiki/%E3%82%AD%E3%83%A3%E3%83%A9%E3%82%AF%E3%82%BF%E3%83%A6%E3%83%BC%E3%82%B6%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%95%E3%82%A7%E3%83%BC%E3%82%B9){target="_blank"} に慣れていない人は，このファイル操作の内容がさっぱり分からないかもしれません。
現代のOSは，[GUI](https://ja.wikipedia.org/wiki/%E3%82%B0%E3%83%A9%E3%83%95%E3%82%A3%E3%82%AB%E3%83%AB%E3%83%A6%E3%83%BC%E3%82%B6%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%95%E3%82%A7%E3%83%BC%E3%82%B9){target="_blank"} であるため，無理もない話です。
そこで，ここで簡単に CUI の話をしておきます。

#### ディレクトリ構造

まず，Windowsのディレクトリ構造について説明します。
macOSもほぼ同じです。

Rを起動した時，Rコンソールは次の場所（フォルダ）にいます。
```{mermaid}
graph LR
  C[C:] --- Users
  Users --- ユーザ名
  ユーザ名 --- OneDrive
  OneDrive --- ドキュメント
```
「いる」というのは，Explorer（またはFinder）でその場所を開いていることと同じと思ってください。
Rは，この場所で作業をします。
ここで，`ユーザ名` は今使っているパソコンにログインしているユーザ名のことで，パソコンによって異なります。

この図の線の部分を `/` で置き換えると，CUIで表現できます。
つまり，上の図はCUIでは `C:/Users/ユーザ名/OneDrive/ドキュメント` と表現します（Windowsの場合，`/` を `¥` や `\` で表現する場合もあります）。

一方，Webブラウザを使ってダウンロードしたファイルは，デフォルトでは次の図の `Downloads` にあるはずです。
```{mermaid}
graph LR
  C[C:] --- Users
  Users --- ユーザ名
  ユーザ名 --- OneDrive
  OneDrive --- ドキュメント
  ユーザ名 --- Downloads
```
`Downloads` はカタカナで `ダウンロード` かもしれません。

以下の説明では，これらのことが理解できていることを前提としています。

#### ファイル管理

続いて，ファイル管理について説明します。
これは，Rとは直接は関係ありません。
パソコンの中のファイルの整理方法の説明です。

人によってファイルの整理方法は異なります。
このため，ここに書いてある通りにすべきということではありません。
ただし，以下の説明はここに書いてあることを想定しています。

自分で作ったWordやExcelのファイルだけでなく，インターネットからダウンロードしたファイルは，`ドキュメント` 以下の関連するフォルダに移動させることを強くおすすめします。
そうしないと，`ダウンロード` フォルダが訳が分からない状態になってしまします。

`ドキュメント` フォルダも同様で，何もルールを決めずにファイルを保存していると，何が何だか分からなくなってしまいます。
そこで，`ドキュメント` の中にフォルダを作ります。
フォルダの名前は自分で決めてください。
そのフォルダに関連するファイルをフォルダの中に入れていきます。
これらの作業は，Explorer（またはFinder）上で，マウスやトラックパッドを使って行ってください。
そのフォルダの中に，新たなフォルダを作ります。
このフォルダの名前も自分で決めてください。
こうして作成したフォルダは，ツリー状に表現できます。

前節の図の `ドキュメント` 以下のフォルダ構造の例を示すと，以下のようになります。
```{mermaid}
flowchart LR
  ドキュメント --- 大学
  ドキュメント --- 就職活動
  大学 --- 学部
  大学 --- 大学院
  大学院 --- 修士課程1年
  大学院 --- 修士課程2年
  修士課程1年 --- 授業科目A
  修士課程1年 --- 授業科目B
  授業科目A --- 2023年6月21日
  授業科目A --- 2023年6月28日
  授業科目A --- data
```
`就職活動` を `大学` の中に入れたい人やまったく別のフォルダ構造にしたい人もいるでしょう。
自分の好きなようにしてください。
ただし，以下の説明では，日付のフォルダに，Rスクリプトや授業に関連するファイルを入れ，`data` フォルダにダウンロードしたファイルを入れることを想定した説明をします。

自分なりに分かりやすいフォルダを作って，ファイルを整理してください。

### 作業ディレクトリ

対処方法の1つ目は，Explorer（Windowsの場合）またはFinder（macOSの場合）でのファイル操作を伴います。
ダウンロードしたCSVファイルがどこにあるか分からない場合は，Webブラウザの設定を確認してください。
ダウンロードしたCSVファイルがどこにあるかは分かったとして，そのファイルをどこに移動すればよいでしょうか。
ファイルの移動先は，以下のコマンドの返り値が指す**ディレクトリ**です（ディレクトリはフォルダと同じ意味です。正式にはディレクトリと呼び，GUIを使うときはフォルダと呼ぶことが多いです）。
```{r}
#| eval: false
getwd()
```
ただし，このコマンドの返り値のディレクトリで**本当に**よいかは，その人によります。
といっても分からないと思いますので，作業ディレクトリは次の方法で変更しましょう。

Windowsの場合，メニューの[ファイル]→[ディレクトリの変更…]から作業ディレクトリを変更します。
macOSの場合，メニューの[その他]→[作業ディレクトリの変更…]から作業ディレクトリを変更します。
ここで，先ほどCSVファイルがダウンロードされたディレクトリを指定すればよいです。
しかしながら，ここでは，**作業ディレクトリをどこかに決める**ことをおすすめします。
作業ディレクトリはRを終了すると初期化されます（デフォルト値に戻る）ので，Rを起動するたびに毎回，この操作を行います。
毎回同じ場所でもよいですし，通常は目的（プロジェクト，論文，授業など）ごとに変更すべきでしょう。
どこを作業ディレクトリにするかは自分で決めてください。
Rに関連するファイルしか存在しないディレクトリを作成しておくと，作業がしやすいです。

例えば，`ドキュメント` ディレクトリの中に授業のディレクトリを作成し，その中に授業の回数ごとにディレクトリを作成する方法が考えられます。
そこでは，Rのプログラムに関するファイルを作成しておくとよいでしょう。
Rのプログラムが書かれたもの（関数やコマンドのかたまり）を，コードと言ったり，スクリプトと言ったりします。
これらスクリプトが書かれたファイルは，拡張子を `R` として，文字コードがUTF-8のテキストファイルとして保存します。
拡張子が `R` のファイルは，ダブルクリックして開いても構いませんが，テキストエディタで開くことをおすすめします。
テキストエディタは，Windowsの場合は [秀丸エディタ](https://hide.maruo.co.jp/software/hidemaru.html){target="_blank"} が有名で，おすすめです。
秀丸エディタは有料ですが，学生は支払いが免除されるはずでし，支払わなくても警告が出たときにその警告を閉じれば作業できます（メモ帳は改行コードのバグがあるためおすすめしません）。
macOSの場合はOS標準のテキストエディット.appで問題ありません。
最近は，OSに関係なく，[Visual Studio Code](https://code.visualstudio.com/){target="_blank"} を使うのもよいかもしれません。
Rのスクリプトに書かれたコードを必要な部分だけコピーして，Rコンソールにペーストしてから，実行してください。
[Visual Studio Code](https://code.visualstudio.com/){target="_blank"} には，お節介機能が多いため，Rを直接実行できますが，Rに慣れないうちはRコンソールから実行するようにしてください。

上記のようなマウス操作をしない方法もあり，操作をRコンソール内で完結させることができます。
次のコマンドを知っておくと便利です。
```{r}
#| eval: false
setwd("C:/Users/ユーザ名/OneDrive/ドキュメント")
```
このコマンドの `""` の中には，自分のパソコンのディレクトリ構造の場所を指定します。
この場所は，Windowsなら `C:` から始まり，macOSなら `/` から始まる階層構造における位置のことで，パスと呼びます。
このパスはファイル名ではなく，ディレクトリ名で終わることに注意してください。
ここで行っているのは，作業ディレクトリの変更です。

### 絶対パス

エラーへの対処方法の2つ目は，Rコンソールの場所は移動せずに，コマンド実行時に絶対パスを指定する方法です。
これは，次のコマンドによって実現します。
```{r}
#| label: comment
#| eval: false
read.csv("C:/Users/ユーザ名/Downloads/addresses.csv") # Windowsの例
# read.csv("/Users/ユーザ名/Downloads/addresses.csv") # macOSの例
```
Windowsの場合（おそらくWindows 11以降），ダウンロードしたファイルを右クリックして，「パスのコピー」をクリックすると，クリップボードにそのファイルの絶対パスがコピーされます。
コピーした後，`read.csv("")` にある2つの `"` の間にペーストしてください。
macOSの場合，Terminal.appを起動して，そのウィンドウにダウンロードしたファイルをドラッグ＆ドロップすれば，絶対パスが表示されます。
絶対パス正しければ，上のコマンドでCSVファイルの中身が表示されるはずです。

実際には，Rを起動した直後に作業ディレクトリを一度変更し，その後は相対パスを変更しながら，ファイルの読み書きをすることになるはずです。
なお，こうした煩雑さを緩和する目的で，[here](https://CRAN.R-project.org/package=here){target="_blank"} パッケージがありますので，知りたい人は調べてください。

### 相対パス

相対パスは現在の作業ディレクトリを起点として，相対的にどこのファイルを読み書きするかを指定する考え方です。
Rによるディレクトリの作成と合わせて考えると非常に便利です。

例えば，作業ディレクトリの下に新たなディレクトリを作成し，そこにファイルをダウンロードした後に，そのファイルを読むには次のようにします。
```{r}
#| eval: false
dir.create("./test")
download.file("https://people.sc.fsu.edu/~jburkardt/data/csv/addresses.csv", "./test/addresses.csv")
read.csv("./test/addresses.csv")
```
```{r}
#| echo: false
#| warning: false
download.file("https://people.sc.fsu.edu/~jburkardt/data/csv/addresses.csv", "../data/addresses.csv")
read.csv("../data/addresses.csv")
```
パスの先頭にある `.` は自分がいるディレクトリを強調して表現したいときに用いる記号です。
このことから，`./` は作業ディレクトリを意味します。
この部分はなくても構いません。
ただし，`"./test"` と `"test"` は同じ意味ですが，`"/test"` は意味が異なりますので注意してください。
もし `dir.create("/test")` とした場合，作業ディレクトリではなく，ルートディレクトリに新たなディレクトリが作成されます（こうした操作はOSにとって脅威となりますので，絶対にやらないでください）。

上述のコードは，`dir.create()` でディレクトリを作成し，`download.file()` でファイルをダウンロードした後，`read.csv()` でダウンロードしたファイルを読み込みます。

この結果を見て，1行目の左側に数字がついておらず，2行目が1，6行目が6となっています。
これは，Rが1行目をヘッダーとして読み込んでいるという意味です。
これで正しい場合もありますが，この例は1行目もレコードなので，次のようにしなければなりません。
```{r}
read.csv("../data/addresses.csv", header = FALSE)
```
ヘッダーをどうすべきかはファイルによって異なります。
例えば，次の例では，ヘッダーを `TRUE` にすべきです（省略時のヘッダーは `TRUE` であるため，省略してもよい）。 
```{r}
download.file("https://people.sc.fsu.edu/~jburkardt/data/csv/airtravel.csv", "../data/airtravel.csv")
read.csv("../data/airtravel.csv", header = TRUE)
```
ヘッダーがおかしいものがありますが，ここでは無視します（この節の最後のやり方でこのおかしさは解消します）。
あえて間違った読み方をすると次のようになります。
```{r}
read.csv("../data/airtravel.csv", header = FALSE)
```

正しく読み込めたかどうかは，Rの表示と元のCSVファイル（テキストエディタやMicrosoft Excelを使って表示）を比較して確かめてください。
以上の例のように，一度ダウンロードしたファイルは自分のパソコンに残っているため，`read.csv()` を使って何度も読み直すときに `download.file()` は必要ありません。
これは，Explorer（Windowsの場合）やFinder（macOSの場合）における通常のファイル操作と同じです。

なお，パスの先頭に `..` または `../` を書くこともできます。
これらの記号は，作業ディレクトリのひとつ上の階層のディレクトリを意味します。
`.` と `..` は同時には使えません。
どちらもパスの先頭になければならないからです。
次のコードは，Rの作業ディレクトリの1つ上の階層に，dataという名前のディレクトリを作成するもので，ファイルの出力先を指定する際に頻繁に使います。
```{r}
#| eval: false
outdir <- "../data"
if (!file.exists(outdir)) {
  dir.create(outdir)
}
```
2行目と4行目は，すでにそのディレクトリがある場合は，何もしないことを意味しています。
このコマンドを理解するには，次回説明する条件分岐と `!` の意味を正しく理解できなければなりません。
ここで，outdirという名前の変数を作っているのは，それ以降に同じ記述が2回登場するためです。
後になって，もしディレクトリを変更したくなった場合，2箇所修正するよりも1箇所修正する方が間違いが少なくてすみます。
なお，この考え方に基づくと，CSVファイルを読むコマンドは以下のように書き換えることができます。
```{r}
outdir <- "../data"
if (!file.exists(outdir)) {
  dir.create(outdir)
}
destfile <- "../data/biostats.csv"
if (!file.exists(destfile)) {
  utils::download.file("https://people.sc.fsu.edu/~jburkardt/data/csv/biostats.csv", destfile)
}
read.csv(destfile)
```
コードは複雑になりましたが，読み込みたいファイルがすでにダウンロードされている場合は，再びダウンロードしないため，こちらの方がネットワークへの負荷が少なく，よりよいコードと言えます。
ただし，元のファイルと比較するとヘッダーがおかしいです。
CSVファイルのヘッダーを変更せずにそのまま読むには，次のようにします。
```{r}
read.csv(destfile, check.names = FALSE)
```


## 特殊記号

### コメント

これまでの説明で登場しましたが，何も説明しなかった大事なことをここで説明しておきます。

`#` で始まる行は**コメント**です。
行の途中に `#` がある場合は，そこから右，改行までの文字がコメントとみなされます。
Rはコメントを無視します。
コメントは人間が読んで理解できるようなことを書くのに重宝します。
Rはコメントを無視するため，何を書いても構いません。

上記の `read.csv()` の例では，Windowsの場合とmacOSの場合を例示するのに，注釈としてコマンドの右に `#` を付けて説明しました。
このような使い方と同時に，macOSの場合を示した2行目は行頭にも `#` を付けています。
これは，この2行を実行することはない（実行してはいけない）ため，このような記述にしています。
macOSの人は `#` の右側のみをコピーしてください。
このように排他的であることを明示するために，コメントを使うこともあります。
他には，「このコードは一部の人のみ実行してください」や「このコードは実行しなくてもよい」といった意味で使用することもあります。

### セミコロン

通常，Rでは1行に複数のコマンドを書きません。
ただし，1行に複数のコマンドを書くこともできます。
何らかの理由により，1行に複数のコマンドを書きたい場合は，次のように `;` で繋げます。
```{r}
x <- 1:100; sum(x)
```
ただし，こうしたからといって処理速度が速くなることはありません。

セミコロンを使って書くと，コマンドと返り値の順番に変化がもたらされます。
```{r}
sum(x)
mean(x)
```
セミコロンのない場合とある場合とで，コマンドと返り値が表示される順番に違いがあることに注目してください。
```{r}
sum(x); mean(x)
```
返り値がまとまってほしいときに便利ですが，そうなってほしいことは滅多にありません。

### 評価と同時に返り値を表示

コマンドを実行して，返り値を得ることを評価と呼びます。
このとき，同時に，その返り値を表示したい場合，コマンド全体を `()` で括ります。
```{r}
(x <- 10)
```
関数の `()` とは異なり，全体を `()` で括ります。
これは次のようなコマンドを実行するのと同じことです。
```{r}
x <- 10
x
```
このように冗長に書くよりも，`()` を使った方が分かりやすいことがたまにあります。


## 変数の型

変数の型には，数値，文字列，ファクター（因子），論理値があります。
以下のどれかのコマンドを使って，その変数の型を知ることができます。
```{r}
#| eval: false
typeof()
mode()
class()
```
ただし，常に意識するというよりは，エラーの原因追及（バグフィックス）時に必要な知識です。
このため，自分が書いたスクリプトにバグが入らないようにしたいなら，この変数の型を意識しておかなければなりません。
変数の型には次の種類があります。

1. 実数
1. 整数
1. 文字列
1. ファクター
1. 論理値

### 数値

実数と整数はいずれも数値で，区別しなくても困りません。
数値は計算できます。
任意のオブジェクトが数値かどうかを判定したいときは，`is.double()` または `is.numeric()` を用います。
```{r}
x <- 10
is.double(x)
# is.numeric(x)
```
返り値の `TRUE` は真という意味で，判定（知りたいこと）が真のときに `TRUE` が返ってきます。

Rではデフォルトで数値は実数として扱われます。
数字を扱うにあたって，それ以上のことを考える必要はありません。
もし整数として明示的に扱いたい場合は，次の関係を知っておいてください。
```{r}
x <- 10
is.integer(x)
x <- 10L
is.integer(x)
x <- as.integer(10)
is.integer(x)
```
また，整数は整数として意識的に維持しなければ，容易に実数に変化します。
```{r}
10L + 2; is.integer(10L + 2)
10L + 2L; is.integer(10L + 2L)
```

### 文字列

文字列は文字として表現されるもので，`""` で括って表記します。
多くの場合，`""` は `''` で代替できます。
ただし，Rの返り値は必ず `""` で括られますので，`''` ではなく `""` を使うようにしてください。
```{r}
c('a', "文字", 'b')
```
文字列の中に `"` を入れたい場合に `''` を使うと分かりやすくなりますが，その場合でも `""` は使えます。
```{r}
x <- "\"あ\""
x
```
`\` のことを**エスケープシーケンス**と呼びます。
それでは，文字列の中に `\` を入れたい場合はどうすればよいでしょうか？
次のようにします。
```{r}
x <- "\\\"あ"
x
```
一見意味が分かりにくい出力ですが，エスケープシーケンスとしての `\` なのか文字としての `\` なのかは考えれば分かるはずです。

数値を文字列に変換する場合は，`as.character()` を使います。
ただし，`paste()` の方が便利なため，`paste()` を頻繁に使うことになるでしょう。
例えば次のようにします。
```{r}
paste(2000:2010, "年", sep = "")
```
`paste()` は文字列を繋げる関数です。
引数には文字列を取りますので，引数に数値がある場合は，勝手に文字列に変換されます。

### ファクター

ファクターは見た目は文字列ですが，以下の特徴があります。

- 取り得る値の数が有限である。
- グループ分けに使える。
- 値に順番のようなものがある。

例えば，学生の成績は「秀」「優」「良」「可」「不可」で表現されます。
あるいは，「S」「A」「B」「C」「D」といった表現もあります。
これらの文字列には順番があります。
また，「愛媛県」は文字列で，一見順番は関係なさそうですが，都道府県コードというものが割り振られており，都道府県別に並べるとき，愛媛県は38番目に表示するというルールがあります。
「北海道」が01で，「沖縄県」が47です。
他に，アンケート調査の選択のある問に対する解答として，「強くそう思う」「ややそう思う」「どちらでもない」「あまりそう思わない」「まったくそう思わない」といったデータがあり得ます。
こうしたデータを扱う場合，ファクターを文字列として考えていると，思い通りの表示にならなかったり，処理できずエラーが返ってくることがあります。

次のデータがあったとします。
```{r}
grade <- c("優", "良", "可", "良", "良", "不可", "秀", "優", "可", "良")
grade
```
この変数 `grade` に順番を持たせるためには，次のようにします。
```{r}
grade2 <- factor(grade, levels = c("秀", "優", "良", "可", "不可"))
grade2
```
ファクターの返り値に順番が `Levels` として表記されます。
この `Levels` はファクターに付けられたラベルであり，次のコマンドで取り出せます。
```{r}
levels(grade2)
```
ファクターのラベルを変更すれば，ファクターの各要素の値も変わります。
```{r}
levels(grade2) <- c("S", "A", "B", "C", "D")
grade2
```
ファクターを文字列に変換すれば，ラベル（順番の情報）は失われます。
```{r}
as.character(grade2)
```

上述の説明は**順番のようなもの**の存在を暗黙裏に扱っており，通常の使用ではこれで問題ありません。
もし明示的に**順番**を扱いたい場合は，次のようにする必要があります。
```{r}
factor(grade, levels = c("不可", "可", "良", "優", "秀"), ordered = TRUE)
```
また，上述のアンケート調査の例では，実際は，ファクターではなく，数値に変換して分析することもあります。
```{r}
as.double(factor(grade, levels = c("不可", "可", "良", "優", "秀")))
```

### 論理値

オブジェクトの状態を表すものに，`TRUE` と `FALSE` があります。
日本語では，`TRUE` は真で，`FALSE` で偽と表現します。
これまで関数の引数として登場しました。

`TRUE` は `T` と省略でき，`FALSE` は `F` と省略できることを知っておいてください。
ただし，自分では `T` や `F` を使わないでください。
複雑なコードのときに，`T` や `F` よりも，`TRUE` や `FALSE` の方が分かりやすいからです。
もしどこかで`T` や `F` を見かけたら，頭の中でそれぞれ `TRUE` と `FALSE` に置き換えてください。
なお，`True` や `true` ではなく，必ず大文字を使ってください。

論理値は，真偽を確かめたいときに関数の返り値として用いられます。
このとき，論理値が計算できることを知っておくと役に立つ場面がある。
```{r}
x <- rep(TRUE, 10)
x
sum(x)
```
この例のように，`TRUE` のベクトルをわざわざ生成することは実際はないが，比較演算子を用いた判定の返り値を計算に利用することはよくある。
このとき，`sum()` は `TRUE` の数に一致する。
すなわち，`TRUE` の数を数えていると理解してもよい。
実際には，R内部で `TRUE` は数値の `1` に変換され，`FALSE` は数値の `0` に変換された後，`sum()` が適用されている。


## 変数の種類

変数の種類といってよいのかどうか分かりませんが，変数には以下の種類のものがあります。

1. ベクトル
1. 行列
1. データフレーム
1. リスト

### ベクトル

ベクトルは，`c()` で作成します。
`seq()` などの関数のように，返り値がベクトルとなるものもあります。
```{r}
c(10, 12, 15, 20)
```
ベクトルの四則演算はベクトルを返します。
```{r}
c(10, 12, 15, 20) * 5
```
列ベクトルか行ベクトルかはあまり気にする必要はありません。
ベクトルの転置は次のようにします。
```{r}
x <- 1990:2020
x
t(x)
```
このことから，`x` と `x` を転置した `t(x)` は違うことが分かります。

ベクトルは数値である必要はなく，文字列のベクトルも作成できます。
```{r}
c("テニス", "バレーボール", "野球", "サッカー")
```
ただし，ベクトルの各要素の型は同じでなければなりません。
例えば，数値と文字列を混ぜた場合，そのベクトルは文字列になります。
```{r}
#| error: true
x <- c(1, "テニス", 3)
x[1] + x[3]
```
文字列は，たとえ見た目が数値であったとしても，計算できません。
文字列は必ず `""` で括られています。
```{r}
x
```

ただし，文字列の中が数値の場合，その文字列は数値に変換できます。
文字列を数値に変換する場合は，`as.double()` を用います。
```{r}
as.double(x[1]) + as.double(x[3])
```
次のように，`as.numeric()` でも同じ結果が得られますが，文字列を数値に変換する場合，`as.double()` を使う方が（おそらく）正当なやり方です。
```{r}
as.numeric(x[1]) + as.numeric(x[3])
```

#### 欠損値

データがない部分のことを欠損値と言います。
数値の欠損値は `NA` で表します。
例えば，アンケート調査を実施して，ある回答者がある問の選択問題の解答をしていない場合，そこに `-` を入力してはいけません。
そこには，何も入力しないのが正しいデータ作成の方法です。
Microsoft Excelでデータ入力する場合は，そのセルには何も入力せずに次の入力に移ってください。
ただし，Rでデータ作成する場合，次のようにするとエラーが返ってきます。
```{r}
#| eval: false
c(1, 2, , 4, 5)
```
このため，欠損値には `NA` と書いてください。
```{r}
#| eval: false
c(1, 2, NA, 4, 5)
```
CSVファイルなどをRで読み込むときに欠損値があると，その部分がデフォルトでは `NA` に置き換わります。
ここで，次のようにするとエラーが返ってきます。
```{r}
#| eval: false
c(1, 2, -, 4, 5)
```
また，次のようにすると全体が文字列になります。
```{r}
#| eval: false
c(1, 2, "-", 4, 5)
```

一方，アンケート調査で，文章で回答してもらう問に対して無回答だった場合，そこに `""` を入力してください。
Microsoft Excelでデータ入力する場合は，そのセルには何も入力せずに次の入力に移ってください。
CSVファイルなどをRで読み込むときに欠損値があると，その部分がデフォルトでは `""` に置き換わります。
```{r}
#| eval: false
c("テニスが好き", "バレーボールをやってた", NA, "野球が苦手", "サッカーが得意")
```
これだとエラーは返ってきませんが，あまりよい方法ではありません。
この場合，次のようにしてください。
```{r}
#| eval: false
c("テニスが好き", "バレーボールをやってた", "", "野球が苦手", "サッカーが得意")
```

`NA` に似たものに `NULL` があります。
`NULL` はデータの欠損値には使いません。
`NULL` には例えば次のような使い方があります。
```{r}
#| eval: false
x <- NULL
```

### 行列

Rは行列計算が高速であることが特徴のひとつです。
また，ここには書きませんが，行列を用いた数式の表記は簡潔です。

行列は以下のようにして作成します。
```{r}
matrix(1:12, nrow = 4)
```
`nrow` は行の数です。
行列の要素の数は，`nrow` の値で割り切れなければなりません。
列の数 `ncol` を指定しても構いません。

行列の外側の `[]`で囲まれた部分に注目してください。
`[]` と `,` と数字によって，そこが行列の何行目か，あるいは，何列目かが分かります。
`[行, 列]` という関係になっています。

行列はMicrosoft Excelでよく見る表に似ていますが，そうではなく，数学で出てくる行列そのものだと理解してください。
行列の要素は `[]` を用いて取り出します。
例えば，1行2列の要素は次のようにして取り出します。
```{r}
x <- matrix(1:12, nrow = 4)
x[1, 2]
```
行は次のようにして取り出します。
```{r}
x[2, ]
```
列は次のようにして取り出します。
```{r}
x[, 3]
```
この法則に従って，スペースを入れることを忘れないようにしてください（スペースを入れなくてもエラーは出ません）。

#### Tips

行列はベクトルを折り畳んだようなものであると理解しておくと役に立つことがあります。
次の結果を比較して，行列がベクトルであることを理解してください。
```{r}
matrix(1:12, nrow = 4)[5]
matrix(1:12, nrow = 4, byrow = TRUE)[5]
```
ただし，通常のデータ分析で行列を扱う機会は少ないかもしれません。
次のコマンドが `FALSE` を返すように，厳密にはベクトルではありません。
```{r}
is.vector(matrix(1:12, nrow = 4))
```
しかし，ベクトルであるかのように動作することがあります。

### データフレーム

データフレームはMicrosoft Excelでよく見る表に似ており，そのようなものだと理解してください。
`read.csv()` で読み込んだオブジェクトは，データフレームです。

データフレームには行と列が存在する点では，行列に似ています。
しかしながら，行列とは違い，各列を異なる型にすることができることから，行列よりも柔軟なデータ構造となります。
それぞれの列は同じ型でなければなりません。

Rには最初から多くのデータセットが使える状態になっています。
サンプルとしてよく使われるデータセットに `iris` があります。
`iris` の中身は，`iris` と入力するだけで表示されます。
```{r}
iris
```
`iris` は変数であり，次のコマンドで確かめられるように，データフレームです。
```{r}
is.data.frame(iris)
```
データフレームの全体を表示させることなく，データフレームの構造を知りたいときは，最初の数行を表示させるコマンドを使うのが便利です。
```{r}
head(iris)
```
同じように，最後の数行を表示させることもできます。
```{r}
tail(iris)
```
途中の行を表示させたい場合は，行番号を指定します。
```{r}
iris[100:105, ]
```
データフレームの構造を知りたい場合は，次のようにします。
```{r}
str(iris)
```
データフレームの列ごとに変数の型が表示されることが分かります。
行の数と列の数は次のコマンドで取得できる。
```{r}
dim(iris)
```

#### データフレームの列

データフレームそのものを分析に使うこともできますが，必要な列を取り出して，分析に使うのが一般的です。
そこで，データフレームの列を取り出す方法をいくつか説明します。
なお，データフレームの進化したものに，[tibble](https://tibble.tidyverse.org/){target="_blank"} があります。
tibbleはデータフレームとほとんど同じように扱えますが，データフレームとは挙動が若干異なりますので，違うものと考えてください。
ちなみに，`read_excel()` で読み込んだオブジェクトは，tibbleです。
tibbleは [Tidyverse](https://www.tidyverse.org/){target="_blank"} の一部分（最も重要な部分）を構成します。

データフレームの列を取り出す場合，左から何列目であるかを数値で指定することができます。
次のコマンドにより，データフレームの列をベクトルとして取り出すことができます。
```{r}
iris[, 1]
```
返り値をデータフレームとして保ちたければ，次のようにします。
```{r}
iris[1]
```
次のようにすると，左から1列目をベクトルとして取り出せます。
```{r}
iris[[1]]
```
このことから，`iris[, 1]` と `iris[[1]]` は同じ結果が得られることが分かります。

データフレームの左から何列目かという情報は，対話的にRを使う場合は便利なときもありますが，データフレームの構造を正確に把握しておかなければならず，またデータフレームの列が多くなった場合，何列目かをわざわざ数えなければなりません。
こうした作業は面倒だということもありますが，それ以上に，間違う可能性があります。
列を取り出す際，データフレームの左から何列目かという情報ではなく，列名で指定する方が間違いが少なくなるでしょう。
`iris` の `Sepal.Length` 列を取り出したい場合は，次のように `$` で繋ぎます。
```{r}
iris$Sepal.Length
```
列名が日本語の場合など，次のようにしなければエラーが返ってくることがあります。
```{r}
#| eval: false
iris$`Sepal.Length`
```
日本語の他にも，列名に `()` が使われている場合は，`` で括らなければエラーが返ってきます。
返り値をデータフレームとして保ちたければ，次のようにします。
```{r}
iris["Sepal.Length"]
```
このとき，`""` をつけなければエラーが返ってきます。
ここで，`""` の中は文字列として扱われるため，`` で括る必要はありません。
```{r}
#| error: true
iris[Sepal.Length]
```
このとき，`Sepal.Length` という名前の変数（オブジェクト）を探しに行き，それがないためエラーを返しています。
次のようにすると，ベクトルとして取り出せます。
```{r}
iris[["Sepal.Length"]]
```

ここで，列名を知るにはどうすればよいでしょうか。
`str()` で知ることができますが，`str()` だと情報が多いです。
データフレームの列名のみを得るには，次のコマンドを用います。
```{r}
names(iris)
```
これは次のようにしても同じです。
```{r}
colnames(iris)
```

次に，複数の列を取り出してみます。
`iris` の `Sepal.Length` 列と `Sepal.Width` 列を取り出すには，次のようにします。
```{r}
iris[c("Sepal.Length", "Sepal.Width")]
```
データフレームから複数列を取り出す場合，返り値はベクトルではなく，必ずデータフレームになります。
このため，`$` や `[[]]` は使えません。

ちなみに，以下のような表記法は，返り値としてベクトルが欲しい場合にもデータフレームが欲しい場合にも使えるので，便利です。
しかしながら，tibbleでこの方法は使えないため，残念ながら，こうした表記法は過去のものとなりました。
```{r}
#| eval: false
iris[, "Sepal.Length"]
iris[, "Sepal.Length", drop = FALSE]
iris[, c("Sepal.Length", "Sepal.Width")]
```

#### データフレームの列

データフレームは，`data.frame()` で作成します。
データフレーム作成時に注意すべきことは，各列の長さを合わせるということです。
各列の長さが揃わないときは，短い列を繰り返します。
この繰り返しが整数倍でない場合，エラーが返ってきます。
```{r}
#| eval: false
data.frame(year = 1991:2020, value1 = 1:30, value2 = NA, value3 = c("東", "西", "南"), value4 = 1:5)
```

### リスト

リストはさまざまな変数を入れることのできる，引き出しだと説明されることがあります。
さまざまな変数をリストに入れることができます。
データフレームのように，各要素の数を揃える必要はありません。
Pythonでいう辞書のようなものです。

リストはさまざまな形を取りますが，実践的には，複数のデータフレームを要素とできる点が便利です。
```{r}
#| eval: false
x <- list()
```

また，関数の返り値がリストとなることがあります。
例えば，データフレームをある列（ファクター）に従って分割したい場合，`split()` を用います。
```{r}
x <- split(iris, iris$Species)
x[[1]]
x[[names(x)[2]]]
```


## 練習問題

1. 「北海道」「青森県」といった都道府県の文字も含む日本の全都道府県名を要素とするファクターを作成しなさい。

2. 気象庁の次のWebサイトからCSVファイルをダウンロードして，変数 `temp` に読み込んだ後，世界全体の年平均気温偏差の最大値と最小値を求めなさい。
  - [世界の年平均気温偏差（℃）](https://www.data.jma.go.jp/cpdinfo/temp/list/an_wld.html){target="_blank"} 

3. 次のデータフレーム `z` があるとする。
```{r}
#| eval: false
x <- 1990:2010
y <- seq(5000, 5040, 2)
z <- data.frame(year = x, value = y)
```
2000年代の値（ `value` 列）の平均を求めなさい。
