---
project:
  type: website
  output-dir: docs
title: "比較演算"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
format:
  html:
    toc: true
    toc-title: 目次
    toc_float: true
    toc-depth: 4
    number-sections: true
    theme: simplex
    mermaid:
      theme: neutral
lang: ja
---

今回は比較演算子の使い方を学びます。
比較演算ができるようになれば，条件分岐と繰り返し処理の理解が進みます。


## 比較演算

比較演算とは**比較演算子**を使った判定のことです。
数値の比較はみなさんが日常的に行ってことですので，分かりやすいはずです。

### 数値

比較演算子の1つに `==` があります。
```{r}
year <- 2000
year == 2000
year == 2001
```
`=` は必ず2つ連続で使用します。
`=` を1つしか使わない場合，関数の引数以外では，`<-` と同じ意味になってしまいますので，注意が必要です。
上のコマンドは，`==` の左側と右側が等しいかどうかを判定しています。
比較演算の返り値は論理値です。

また，ベクトルを比較演算子の左側に置いた場合，返り値は左側のベクトルと同じ長さのベクトルになります。
```{r}
year <- 1990:2010
year == 2000
length(year)
length(year == 2000)
```
ベクトルの各要素を表示し，返り値との対応関係が正しいことを確かめてください。
```{r}
year
```
Rコンソールに表示されるベクトルが何行目で改行されるかは，そのベクトルによって異なります。
このため，2行目がベクトルの何番目であるかはそのベクトルに依存します。
左の `[]` 内に表示される数字がベクトルの何番目の要素であるかを示しています。

`==` のほかに，次のような比較演算子があります。
これらの比較演算は直感的に理解できるはずです。
```{r}
year > 2000
year < 2000
year >= 2000
year <= 2000
```
`>=` は `=>` とするとエラーが返ってきます。
`<=` も同様に `<=` としてはいけません。
ここでもベクトルの返り値がベクトルであることに注意してください。

比較演算子の先頭に `!` をつけることができます。
この `!` は否定を意味します。
`==` の場合は，`!=` とすると `==` が真ではないものという意味になります。
```{r}
year != 2000
```
`!=` の返り値は， `==` のちょうど反対であることが分かるはずです。
なお，`!>`，`!<`，`!>=`，`!<=` は使えません。
`>` の否定は `<=` で表現できるため，これらのコマンドが使えなくてもとくに困りません。

比較演算は，ベクトルや行列の一部を取り出すときによく使います。
例えば，次のようにします。
```{r}
year[year >= 2000]
```
一見冗長な書き方のように見えますが，これで問題ありません。
`[]` の内側は論理値のベクトルであり，`[]` の外側（ `year` ）のベクトルと長さが同じ（または，外側が内側の整数倍）でなければなりません。
この場合は `[]` の外側と内側で同じ変数 `year` を使っているので，必ずベクトルの長さが同じになります。
`[]` 外側のベクトルに対して，内側のベクトルの長さが短い場合は，内側のベクトルを繰り返します。
例えば，次のようにすると，`c(TRUE, FALSE, FALSE)` は7回繰り返され，返り値は7つの要素を持つベクトルになります。
```{r}
year[c(TRUE, FALSE, FALSE)]
```
これは，`length(year)` が `r length(year)` でり，これを `length(c(TRUE, FALSE, FALSE))` の `r length(c(TRUE, FALSE, FALSE))` で割ると，`r length(year) / length(c(TRUE, FALSE, FALSE))` になるためです。
もしこの計算によって求められる数値（ここでは `7` ）が整数でなければ，エラーが返ってきます。
例えば，次の場合，エラーが返ってきます。
```{r}
#| error: true
year[c(TRUE, FALSE, FALSE, FALSE)]
```
これは，`length(year)` が `r length(year)` でり，これを `length(c(TRUE, FALSE, FALSE, FALSE))` の `r length(c(TRUE, FALSE, FALSE, FALSE))` で割ると，`r length(year) / length(c(TRUE, FALSE, FALSE, FALSE))` になり，整数ではないためです。

`[]` の外側が内側の整数倍の長さのベクトルという性質を使うことはほとんどないため，このことを知らなくても困ることはほとんどないでしょう。
むしろ，ベクトルの長さが違っていてもエラーにならない可能性があることから，思わぬバグに気づかないかもしれません。

なお，次のようにもできますが，スクリプトの中でのこのような記述は無駄だということに注意してください。
```{r}
year[year == 2000]
```
この場合，次のようにした場合と返り値が同じです。
```{r}
2000
```
返り値を関数の引数に入力してしまっています。
ただし，次のような場合は無駄ではありません。
```{r}
year[year > 2000]
```
こうした比較演算は，実際には，次のような使い方をすることがよくあります。
```{r}
y <- seq(5000, 5040, 2)
z <- data.frame(year = year, value = y)
mean(z[z$year > 2000, ]$value)
```
最後の部分は次のようにしても同じです。
```{r}
mean(z$value[z$year > 2000])
```
このことがいまいちピンとこない人は，次のように分解して考えてみてください。
```{r}
(zd1 <- z$year > 2000)
(zd2 <- z[zd1, ])
(zd3 <- zd2$value)
mean(zd3)
```

これまでの説明で，返り値が論理値であることが混乱を招く原因になっているかもしれません。
しかし，これは R の便利な特徴のひとつですので，必ず理解してください。
もしかしたら，判定が真となる要素がベクトルの何番目の要素であるかを返す関数 `which()` の方が理解が容易でしょうか。
```{r}
which(year >= 2000)
```
このため，次のようにすることができます。
```{r}
(zd <- which(z$year >= 2000))
z$value[zd]
```
ただし，これは次のようにすることと同じです。
```{r}
z$value[z$year >= 2000]
```
返り値と関数の引数は異なります。
このように，ベクトルを取り出すとき，何番目であるかを指定する方法と，論理値で指定する方法の2つがあることを知っておいてください。
今後自分でコードを書くとき，このことが混乱の原因になるかもしれません。
もし混乱した場合は，そのとき扱っている変数が数値なのか論理値なのかを考えると，頭の中が整理されるはずです。

#### `NA`

ベクトルに `NA` が含まれるとき，`NA` のある場所では評価（比較演算）しません。
```{r}
x <- sample(10, 10)
x[sample(10, 1)] <- NA
x > 5
x[x > 5]
```
`NA` を取り除きたい場合は，条件をもう1つ追加しなければなりません。
`NA` かどうかは次の関数で判定します。
```{r}
is.na(x)
```
実践では，`NA` 以外を取り出したい場合は，否定の `!` が使えます。
```{r}
!is.na(x)
```
`NA` を取り除くと，ベクトルの要素の数が減ることに注意してください。
```{r}
length(x[!is.na(x)])
length(x)
```
このベクトルがデータフレームから取り出したものである場合，そのデータフレームに `NA` を取り除いたベクトルを戻すことはできません。
行の対応関係が崩れるため当然ですが，勘違いしやすいので注意してください。
`NA` が含まれる計算結果は `NA` となるため，`NA` を取り除きたくなるかもしれません。
```{r}
sum(x)
```
この場合，関数の引数に `na.rm = TRUE` を入れて，一時的に `NA` を取り除いて計算してください。
```{r}
sum(x, na.rm = TRUE)
```
この場合，`x[!is.na(x)]` のように，ベクトルからわざわざ `NA` を取り除く必要はありません。

判定の際に `NA` を取り除きたい場合は，次のようにします。
```{r}
x[!is.na(x) & x > 5]
```
ここで，`&` は**論理積**と呼ばれるもので，英語の"and"，日本語の「かつ」という意味を持ち，判定の条件を増やすことを意味します。
`NA` に限らず，複数の比較演算を使いたい場合は，論理積 `&` を使います。
もっと単純な例としては，以下のようなものがあります。
```{r}
year[year > 2000 & year < 2005]
```
論理積は以下のベン図で表現できます。
```{r}
#| echo: false
library(ggVennDiagram)
library(ggplot2)

g <- ggVennDiagram(list("year > 2000" = year[year > 2000],
                        "year < 2005" = year[year < 2005]), label = "count") + 
  scale_color_manual(values = rep("black", 3)) +
  theme(legend.position = "none")
g$layers[[1]]$mapping <- aes(fill = name)
g + scale_fill_manual(values = c("year > 2000" = "white", "year < 2005" = "white", "year > 2000..year < 2005" = "lightblue"))
```

一方，複数の比較演算のいずれかが真となるという条件式を書きたい場合は，論理和 `|` を使います。
例えば，次のようにします。
```{r}
year[year > 2005 | year < 1995]
```
論理和は以下のベン図で表現できます。
```{r}
#| echo: false
g <- ggVennDiagram(list("year > 2005" = year[year > 2005],
                        "year < 1995" = year[year < 1995]), label = "count") + 
  scale_color_manual(values = rep("black", 3)) +
  theme(legend.position = "none")
g$layers[[1]]$mapping <- aes(fill = name)
g + scale_fill_manual(values = c("year > 2005" = "lightblue", "year < 1995" = "lightblue", "year > 2005..year < 1995" = "lightblue"))
```

### 文字列

文字列の比較演算子が使えます。
文字列の比較演算は次のようにします。
```{r}
prefecture <- c("北海道", "青森県", "岩手県", "宮城県", "秋田県", "山形県", "福島県",
                "茨城県", "栃木県", "群馬県", "埼玉県", "千葉県", "東京都", "神奈川県",
                "新潟県", "富山県", "石川県", "福井県", "山梨県", "長野県", "岐阜県", "静岡県", "愛知県",
                "三重県", "滋賀県", "京都府", "大阪府", "兵庫県", "奈良県", "和歌山県",
                "鳥取県", "島根県", "岡山県", "広島県", "山口県", "徳島県", "香川県", "愛媛県", "高知県",
                "福岡県", "佐賀県", "長崎県", "熊本県", "大分県", "宮崎県", "鹿児島県", "沖縄県")
prefecture == "愛媛県"
```
数値と同じく，文字列の返り値も論理値です。
文字列の場合，`==` は完全一致を意味します。

文字列の場合，大きさはないため，`>` や `<` といった比較演算子は使えないはずです。
```{r}
prefecture[prefecture > "愛媛県"]
prefecture[prefecture < "愛媛県"]
```
予想に反して，エラーではなく返り値が得られます。
これは，各文字列の文字コードを比較しています。
このことは，次のコマンドでも確認できます。
```{r}
factor(prefecture)
```
`Levels` がおかしな並び順になっていることが確認できます。
こうした文字コードでの順序づけを回避するには，`levels()` を明示的に指定しなければなりません。
```{r}
(prefecture_factor <- factor(prefecture, levels = prefecture, ordered = TRUE))
prefecture_factor[prefecture_factor > "愛媛県"]
```
このようなこともできますが，特別な理由がない限り，文字列の大小比較はしないでください。

さて，文字列のベクトルの中から共通する要素を取り出したいことがあるかもしれません。
例えば，都道府県の中から県のみを取り出したいときに，次のようにしても得たい結果は得られません。
```{r}
prefecture[prefecture == "県"]
```
上述のように，`==` は完全一致を意味するからです。
このとき，次のようにします。
```{r}
prefecture[grep("県", prefecture)]
```
これは正規表現を使った抽出です。
このコマンドはやや冗長で，本来なら次のようにすべきです。
```{r}
grep("県", prefecture, value = TRUE)
```
`grep` は正規表現を使った処理ができる関数のひとつです。
ただし，正規表現の理解は初学者には難しいでしょう。

### 正規表現

正規表現を知っているかどうかで，比較演算子の効率的な使い方が飛躍的に向上します。
正規表現は，人間が考えるかのようにコンピュータに考えさせる記述方法です。
しかし，非常にややこしいのでここでは説明しません。
以下のWebページを確認してください。

- [R における正規表現 - RjpWiki](http://www.okadajp.org/RWiki/?R+%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%8F%BE){target="_blank"} 


## 条件分岐

条件分岐とは，「もし〜ならば」という条件「〜」を満たす場合に，指定の処理をする手続きのことです。
```{r}
x <- 1
if (x == 1) {
  print("正解です。")
}
```
このように，`if` と `()` の間にスペースを入れます。
また，`{}` の前後は改行し，`{}` の中は左にインデントを付けるようにしてください。
インデントは，スペース2つが一般的です（スペースを4つ付ける人もいます）。

`if` 文は，「そうでなければ」ということを意味する `else` を伴うこともできます。
```{r}
x <- 1
if (x == 1) {
  print("正解です。")
} else {
  print("不正解です。")
}
```

```{r}
x <- sample(1:5)
if (x[1] == 1) {
  print("正解です。")
} else {
  print("不正解です。")
}
```

`if` 文の `()` の中は，長さ1のベクトル（つまり，スカラー）かつ論理値でなければなりません。
すなわち，`if` 文の `()` の中は `TRUE` か `FALSE` です。
もしベクトルの要素1つずつ処理したい場合は，次に説明する繰り返し処理と組み合わせて使います。


## 繰り返し処理

```{r}
x <- 1
for (i in 1:10) {
  x <- x + 1
}
x
```
このように，`for` と `()` の間にスペースを入れます。
また，`for` 文と同じように，`{}` の前後は改行し，`{}` の中は左にインデントを付けるようにしてください。

`for` 文を使うときは，必ずループから抜け出せるようにしてください。
例えば，`for` の引数に `{}` の中で代入した場合，無限ループになることがあります。

繰り返し処理には，`for` 文意外に `while` 文もあります。


## データ・クリーニング

よく使う関数に次のようなものがある。
```{r}
#| eval: false
table()
unique()
order()
apply()
sapply()
lapply()
```

例えば，次のように使う。
```{r}
table(iris$Species)
unique(iris$Species)
order(iris$Sepal.Length, decreasing = TRUE)
head(iris[order(iris$Sepal.Length, decreasing = TRUE), ])
```

論理式での数値は，`0` のみが `FALSE` として扱われ，それ以外は `TRUE` として扱われます。
```{r}
as.logical(1)
as.logical(0)
```


## 関数の作成

関数を自分で作ることができます。
```{r}
x <- function (y) {
  paste(y, collapse = "/")
}
x(c("Apple", "Orange"))
```


## 練習問題

1. ポケモンの中から，water タイプのポケモンをすべて挙げなさい。
ただし，ポケモンのデータセットは，`d3po` パッケージの `pokemon` を使いなさい。
```{r}
#| eval: false
#| include: false
library(d3po)
pokemon[c(which(pokemon$type_1 == "water"), which(pokemon$type_2 == "water")), ]$name
```
1. 「北海道」「青森」…「東京都」…といった都道府県のデータがあります。北海道には「道」の文字が付いていますが，都府県には「都」「府」「県」の文字が付いていません。そこで，都府県にも「都府県」を付けて，すべてのデータが「都道府県」で終わるように揃えたいとします。ただし，データの中には47都道府県がすべて含まれているかどうか，重複があるかどうかは分かりません。すべてのデータが「都道府県」で終わるように揃えなさい。
