---
project:
  type: website
  output-dir: docs
title: "比較演算"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
format:
  html:
    toc: true
    toc-title: 目次
    toc_float: true
    toc-depth: 4
    number-sections: true
    theme: sketchy
lang: ja
---

今回は比較演算子の使い方を知るとともに，条件分岐と繰り返し処理について学びます。

## 比較演算

### 数値

比較演算は，**比較演算子**を使った判定のことです。
比較演算子として分かりやすいのは，`==` です。
```{r}
year <- 1990:2010
year == 2000
```
`=` は必ず2つ連続で使用します。
`=` を1つしか使わない場合，関数の引数以外では，`<-` と同じ意味になってしまいます。
比較演算の返り値は論理値です。

次のような比較は直感的に理解できるはずです。
```{r}
year > 2000
year < 2000
year >= 2000
year <= 2000
```
`>=` は `=>` とするとエラーが返ってきます。
`<=` も同様に `<=` としてはいけません。

比較演算子の先頭に `!` をつけることができ，この `!` は否定を意味します。
`==` の場合は，`!=` とすると `==` が真ではないものという意味になります。
```{r}
year != 2000
```
`!>`，`!<`，`!>=`，`!<=` は使えません。
`>` の否定は `<=` で表現できるため，不便ではありません。

比較演算は，実践では，ベクトルや行列の一部を取り出すときによく使います。
例えば，次のようにします。
```{r}
year[year >= 2000]
```
一見冗長な書き方のように見えますが，これで問題ありません。
`[]` の内側は論理値のベクトルであり，`[]` の外側（ `year` ）のベクトルと長さが同じ（または，外側が内側の整数倍）でなければなりません。
この場合は同じ変数 `year` を使っているので，必ずベクトルの長さが同じになります。

なお，次のようにもできますが，スクリプトの中でのこのような記述は無駄だということに注意してください。
```{r}
year[year == 2000]
```
この場合，次のようにした場合と返り値が同じです。
```{r}
2000
```
返り値を関数の引数に入力してしまっています。
ただし，次のような場合は無駄ではありません。
```{r}
year[year > 2000]
```
こうした比較演算は，実際には，次のような使い方をすることがよくあります。
```{r}
y <- seq(5000, 5040, 2)
z <- data.frame(year = year, value = y)
mean(z[z$year > 2000, ]$value)
```

`which()` は判定が真となる要素がベクトルの何番目の要素であるかを返す関数です。
```{r}
which(year >= 2000)
```
このため，次のようにすることができます。
```{r}
z$value[which(z$year >= 2000)]
```
ただし，これは次のようにすることと同じです。
```{r}
z$value[z$year >= 2000]
```
返り値と関数の引数は異なります。
このように，ベクトルを取り出すとき，何番目であるかを指定する方法と，論理値で指定する方法の2つがあることを知っておいてください。
もしかしたらこのことが，今後自分でコードを書くとき，混乱の原因になるかもしれません。
もし混乱した場合は，そのとき扱っている変数が数値なのか論理値なのかを考えると，頭の中が整理されるはずです。

#### `NA`

ベクトルに `NA` が含まれるとき，`NA` のある場所では比較演算をしません。
```{r}
x <- sample(10, 10)
x[sample(10, 1)] <- NA
x > 5
x[x > 5]
```
`NA` を取り除きたい場合は，条件をもう1つ追加しなければなりません。
`NA` かどうかは次の関数で判定します。
```{r}
is.na(x)
```
`NA` 以外を取り出したい場合は，否定の `!` が使えます。
```{r}
!is.na(x)
```
`NA` を取り除くと，ベクトルの要素の数が減ることに注意してください。
```{r}
length(x[!is.na(x)])
length(x)
```
このベクトルがデータフレームから取り出したものである場合，そのデータフレームに `NA` を取り除いたベクトルを戻すことはできません。
行の対応関係が崩れるため当然ですが，勘違いしやすいので注意してください。
`NA` が含まれる計算結果は `NA` となるため，`NA` を取り除きたくなるかもしれません。
```{r}
sum(x)
```
`NA` を取り除いて計算する方法はありますので，たいていの場合は，ベクトルからわざわざ `NA` を取り除く必要はありません。
```{r}
sum(x, na.rm = TRUE)
```

判定の際に `NA` を取り除きたい場合は，次のようにします。
```{r}
x[!is.na(x) & x > 5]
```
ここで，`&` は**論理積**と呼ばれるもので，英語の"and"，日本語の「かつ」という意味で，判定の条件を増やすことを意味します。
`NA` に限らず，複数の比較演算を使いたい場合は，論理積 `&` を使います。
同様に，複数の比較演算のいずれかが真となるという条件式を書きたい場合は，論理和 `|` を使います。
例えば，次のようにします。
```{r}
x2 <- x[!is.na(x)]
x2[x2 < 3 | x2 > 7]
```

### 文字列

文字列の比較演算子が使えます。
文字列の比較演算は次のようにします。
```{r}
prefecture <- c("北海道", "青森県", "岩手県", "宮城県", "秋田県", "山形県", "福島県",
                "茨城県", "栃木県", "群馬県", "埼玉県", "千葉県", "東京都", "神奈川県",
                "新潟県", "富山県", "石川県", "福井県", "山梨県", "長野県", "岐阜県", "静岡県", "愛知県",
                "三重県", "滋賀県", "京都府", "大阪府", "兵庫県", "奈良県", "和歌山県",
                "鳥取県", "島根県", "岡山県", "広島県", "山口県", "徳島県", "香川県", "愛媛県", "高知県",
                "福岡県", "佐賀県", "長崎県", "熊本県", "大分県", "宮崎県", "鹿児島県", "沖縄県")
prefecture == "愛媛県"
```
数値と同じく，文字列の返り値も論理値です。
文字列の場合，`==` は完全一致を意味します。

文字列の場合，大きさはないため，`>` や `<` といった比較演算子は使えないはずです。
```{r}
prefecture[prefecture > "愛媛県"]
prefecture[prefecture < "愛媛県"]
```
予想に反して，エラーではなく返り値が得られます。
これは，各文字列の文字コードを比較しています。
このことは，次のコマンドでも確認できます。
```{r}
factor(prefecture)
```
`Levels` がおかしな並び順になっていることが確認できます。
こうした文字コードでの順序づけを回避するには，`levels()` を明示的に指定しなければなりません。
```{r}
(prefecture_factor <- factor(prefecture, levels = prefecture, ordered = TRUE))
prefecture_factor[prefecture_factor > "愛媛県"]
```
このようなこともできますが，特別な理由がない限り，文字列の大小比較はしないでください。

さて，文字列のベクトルの中から共通する要素を取り出したいことがあるかもしれません。
例えば，都道府県の中から県のみを取り出したいときに，次のようにしてもほしい結果は得られません。
```{r}
prefecture[prefecture == "県"]
```
上述のように，`==` は完全一致を意味するからです。
このとき，次のようにします。
```{r}
prefecture[grep("県", prefecture)]
```
これは正規表現を使った抽出です。
このコマンドはやや冗長で，本来なら次のようにすべきです。
```{r}
grep("県", prefecture, value = TRUE)
```
正規表現を理解すると，できることが飛躍的に上昇します。



## 条件分岐


```{r}
#| eval: false
if () {
  x
}
```




## 繰り返し処理



```{r}
#| eval: false
i <- 1
for (i > 10) {
  print(i, "\n")
  i <- i + 1
}
```


## データ・クリーニング


```{r}
#| eval: false
よく使う関数
table()
unique()
apply()
```

x[-c(1, 2)]

paste("a", "b")
paste("a", "b", sep = "")
paste0("a", "b")
paste("a", "b", callapse = ", ")


paste(1990:2020, "年", sep = "")



&&
||

論理式での数値は，`0` のみが `FALSE` として扱われ，それ以外は `TRUE` として扱われます。
as.logical(1)
as.logical(0)

is.na()
is.null()

### 正規表現

正規表現を知っているかどうかで，比較演算子の効率的な使い方が飛躍的に向上します。
正規表現は，人間が考えるかのようにコンピュータに考えさせる記述方法です。
しかし，非常にややこしいのでここでは説明しません。
以下のWebページを確認してください。

- [R における正規表現 - RjpWiki](http://www.okadajp.org/RWiki/?R+%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%8F%BE)


## 関数の作成

関数を自分で作ることができます。


## 練習問題

1. 気象庁の次のWebサイトからCSVファイルをダウンロードして，変数 `temp` に読み込んだ後，世界全体の最高気温と最低気温を計算しなさい。
  - [世界の年平均気温偏差（℃）](https://www.data.jma.go.jp/cpdinfo/temp/list/an_wld.html)
1. 次のコマンドの無駄を見つけ，よりよいものに修正してください。
```{r}
#| eval: false
x <- 1990:2010
y <- seq(5000, 5050, 50)
z <- data.frame(year = x, value = y)
x$value[which(x$year == 2000)]
```
