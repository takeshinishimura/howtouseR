[["1-まずは使ってみる.html", "1 まずは使ってみる 1.1 環境構築 1.2 基本操作 1.3 練習問題", " 1 まずは使ってみる このサイトに書かれていることを実行するためには，あなたのパソコンでRを使える環境を構築しなければなりません（ここでは，RというアプリケーションとR言語を区別することなく，Rと呼びます。区別する場合，前者を R.app と書くことがありますが，これはmacOSのファイル名に由来する慣習です）。 スマートフォンには対応していないため，必ずパソコンを使ってください。 1.1 環境構築 Rは The Comprehensive R Archive Network から自分のパソコンのOSに対応したものをダウンロードし，インストールしてください。 The Comprehensive R Archive Network は，Googleなどで「CRAN」（読みは「シーラン」または「クラン」）と入力して検索すると，すぐに見つかるはずです。 あなたのパソコンのOSがWindowsなら「Download R for Windows」をクリックし，macOSなら「Download R for macOS」をクリックしてください。 Windowsの場合，次の画面で「base」をクリックするとインストーラをダウンロードするページが表示されるはずです。 macOSの場合，自分のMacのCPUがApple siliconかIntelかで，ダウンロードするファイルが異なります。 自分の環境（OSとCPU）に合ったファイルがダウンロードできたら，そのファイルを使ってRをインストールしてください。 Rの準備はこれだけです。 もしRStudioを使いたければ，インストールしても構いません。 最初にRStudioをインストールするように指示する書籍やウェブサイトがあると思います。 しかし，個人的にはRStudioの使用はおすすめしません。 RStudioが何をするためのものかを知ってからインストールしても遅くありませんので，Rに慣れてから，Rではできないことをするために，RStudioをインストールすることをおすすめします。 Rコマンダー等，他のソフトウェアもインストールする必要はありません。 Rで何ができるか検索した先に，Rに関連するソフトウェア（パッケージではなく）をインストールするよう指示があった場合は，それが何であるのか理解し，本当に必要であることが分かってから，指示に従ってください。 1.2 基本操作 Rを起動すると，Rコンソールが現れます。 macOSの場合はRコンソールのみが表示され，Windowsの場合は全体のウィンドウの中の小さなウィンドウがRコンソールです。 Rコンソールは下から上に流れていき，一番下がコマンドを入力する場所です。 その場所に，&gt; という文字が表示されているはずです。 &gt; のことをプロンプトと呼びます。 ここにコマンドを入力するということを覚えてください。 ここで言うコマンドとは，Rへの命令のことであり，その実態は関数であることが多く，一連のコマンドはコードやスクリプトとして表現されます。 これらの言葉の厳密な使い分けはできなくても問題ありません。 終了するときは，通常のアプリケーションと同じように終了してください。 ただし，Windowsでは「作業スペースを保存しますか？」，macOSでは「ワークスペースのイメージファイルを保存しますか？」と聞かれます。 聞かれたら，「いいえ」または「保存しない」を選択してください。 1.2.1 四則演算 さっそく，計算してみましょう。 プロンプトに続けて，次のように入力してください。 1 + 1 ここで改行については何も書いていないですが，文字列 1 + 1 を入力した後は，必ず Enterキー または Returnキー を押してください。 この操作のことを「実行する」と言います。 1 + 1 を実行すると，次のように表示されるはずです。 ## [1] 2 コマンドを実行した結果表示されるオブジェクトのことを，「返り値」と呼びます。 ここでは， 1 + 1 というコマンドの返り値が，2 であることが分かります。 それでは，2 の前に表示されている [1] は何でしょうか。 これは右に表示されている返り値が，ベクトルの何番目の要素であるかを示したものです（厳密には正しくないが，この理解で問題ない）。 2 はベクトルの1番目の要素（スカラーではない）に当たるため，1番目の 1 が [] の中に表示されます。 ここではベクトルを扱いませんが，実際にベクトルを扱うときに思い出してください。 四則演算は簡単にできます。 いくつか例を挙げますので，他に思いつくまま，いくつでも実行してみてくだしあ。 なお，実行する場合は，1行ずつにしてください。 慣れてくると数行まとめて実行するようになります。 1 + 3 1 - 2 2 * 3 4 / 2 これらの返り値が期待通りかを確かめてください。 この例にあるように，かけ算は * で，割り算は / で表します。 これまでのように，四則演算の記号の前後にはスペースを入力してください。 例えば，次のようにスペースを入れなくても，正しい返り値が得られます。 2+5 3*1.5 6/4 10--2 ただし，スペースを入れないと，人間にとっては見にくくなります。 プログラミングをする場合，人間にとって読みやすいかどうかは重要です。 このため，必ずスペースを入れるように習慣づけてください。 ちなみに，上記の例の2つ目は，正しくは 10 - -2 と書くか，10 - (-2) と書いてください。 マイナス符号の後にスペースを入れると見にくくなるため，入れないのが一般的です（スペースを入れても入れなくても，結果は変わりません）。 読みやすさを優先して，適宜スペースを入れるようにしてください（このページの記述方法は標準的なものです。記述方法をチェックするために，lintr パッケージがあります。ここでは理解する必要はありません）。 どうすれば読みやすくなるかは説明が難しく，たくさんのRコードを読むことで自然に身についていくものです。 計算の順番を指定する場合は，() で括ってください。 ((2 * 3) + 3) / (2 * 1.5) 計算の順番を指定するのに，{} や [] は使ってはいけません。 () は何回入れ子になっても構いません。 ここで，読者のみなさんにお伺いします。 ここまでで，このページに書かれていなかった計算を試してみたでしょうか。 例えば，次の計算結果はどう表示されるのだろうか，と疑問を持ち，確認したでしょうか。 0.2 * 5 1 / 3 10 / 0 0 / 10 プログラミングの学習に重要なのは好奇心です。 書かれていることをコピー&amp;ペーストするだけでは，プログラミングスキルを修得するのはおそらく不可能でしょう。 自分で考えながら，書かれていること以上のことを学習していってください。 いろいろ計算してみたという方は，その調子で学習を進めていってください。 ある瞬間に突然理解が深まるはずです。 1.2.2 変数 Rに値を記憶させるために，変数（より厳密には，オブジェクト）に値を代入すると便利です。 例えば，変数 x に10を代入するには次のコマンドを実行します。 x &lt;- 10 これは次のように書くこともできます。 x = 10 これらは同じ処理をしています。 ただし，R的な（R like）やり方は前者，&lt;- を使う方です。 変数 x に値が入ったことは，次のようにして確認できます。 x あるいは，次のコマンドでも同じ結果が得られます。 print(x) 代入するものは値そのものでなくても，何らかの返り値を持つ数式でも構いません。 また，代入する変数の名前は x である必要はありません。 自分で自由に決められます。 hensuu &lt;- 2 * 3 変数の中身を確認したければ，次のようにします。 hensuu また，変数を使って計算することもできます。 hensuu * 2 変数名は何でも構いません。 例えば，日本語でも大丈夫です。 変数 &lt;- 2 * 10 ただし，日本語の変数名は思わぬトラブルを招く原因になり得ますので，特別な理由がない限り，積極的には使わないことをおすすめします。 一方，数字で始まる変数名は使えません。 例えば，次のコマンドを実行するとエラーが返ってきます。 2 &lt;- 3 2x &lt;- 10 + 2 * b アルファベットで始まる変数名にしてください。 アルファベットの場合，大文字より小文字が望ましく，意味のある名前だと分かりやすいです。 変数名にはアルファベットと数字以外に _ と . を含めることもよくあります。 _ は英単語の区切りとして使うと便利です（例：newnames よりも new_names の方が分かりやすい）。 ただし，_ から始まる変数名はエラーになります。 . は特別な理由がない限り，使わない方がよいです（例：new.names といった変数名は扱うことはできるが，避ける方が無難）。 . から始まる変数名は普通の変数ではないため，使わないようにしてください。 作成した変数を削除する場合は，次のコマンドを実行します。 rm(x) 現在使っている変数名は次のコマンドを実行すると分かります。 ls() また，特定の変数が存在するかは，次のコマンドを実行すると分かります。 exists() いろいろな変数を作りすぎて混乱してしまうことがあるでしょう。 その場合，いったんRを終了して，再びRを起動すると，これまでRコンソールで作成した変数はすべてなくなります。 いったんRを終了したのとほぼ同じことは，次のコマンドでも実行できます。 rm(list = ls()) このコマンドは，変数だけでなく，後述する関数を含む（ほぼ）すべてのオブジェクトが削除されます。 1.2.2.1 Tips . で始まる変数名は通常は作成しません。 この変数は他の変数と若干異なります。 例えば，次のようにしてみるとわかります。 .a &lt;- 10 .a ls() .a という名前の変数が存在するはずですが，一覧には表示されません。 .a も含めて一覧を表示させるためには，次のようにします。 ls(all.names = TRUE) こういう特殊な動きをするため，. で始まる変数名は特別な理由がない限り使わないでください。 1.2.3 関数 先ほどのように文字の直後に () がくるオブジェクトを関数と呼びます。 関数には以下の特徴があります。 一般的に，関数はより複雑な処理（より長いコード）を簡略化したものである。 関数名と ( と ) の3つでひとかたまりである。 関数に続く () の中には，関数のオプションとなる引数（ひきすう）を書く。 ()を付けずに，関数名だけを書くと，その関数の中身を見ることができる。 ?に続けて関数名だけを書くと，その関数のヘルプを参照することができる。 例を挙げましょう。 seq() は数列を生成する関数です。 x &lt;- seq(from = 1, to = 10, by = 1) このとき，from = 1, to = 10, by = 1 の部分が引数です。 この関数は，from から by ずつ to まで値を増やす数列を生成します。 実際に x の中身を確認してみましょう。 x ## [1] 1 2 3 4 5 6 7 8 9 10 関数の引数の名前は省略できます。 例えば，上の記述は以下のように書いても同じです。 seq(1, 10, 1) 引数の値だけを書いた場合，どの引数の値であるかはコンマで区切られた順番によって決まります。 こうした引数の順番をどのようにして知ることができるでしょうか。 後述する関数のヘルプを参照すると，引数の順番を知ることができます。 また，関数のヘルプを参照すると，どのような引数が使えるかも分かります。 ただし，引数の名前は省略できるのですが，自明な場合を除いて，引数の名前は省略しないことをおすすめします。 ここで，上述した by = 1 のときの seq() は以下のように単純化することができることは知っておく必要があります。 1:10 この表記は特殊です。 この形はそのまま覚えておきましょう。 これまでの知識を踏まえて，いろいろ試してください。 seq() の引数の値を変更すると，違う結果が得られることが想像できるはずです。 次のようにすると，x2 と x5 の中身がどうなるか想像し，実際に想像通りになるかを確かめてください。 x2 &lt;- seq(from = 1, to = 100, by = 2) x5 &lt;- seq(from = 1, to = 100, by = 5) 一般的に，関数名は覚えなければなりません。 ある関数の使い方については，ヘルプを参照すると分かります。 ヘルプを参照するためには，次のように関数名の前に ? を書きます。 ?seq 同じ結果は，次のようにしても得られます。 help(seq) これは help という関数を使って，関数のヘルプを参照しています。 1.2.4 ベクトル 次のコードで作成される変数 x はベクトルです。 x &lt;- seq(from = 1, to = 100, by = 2) x の中には 50 個の値が入っており，順番にも意味があります。 このベクトルの2番目の要素は次のようにして取り出すことができます。 x[2] ## [1] 3 長さは次のようにして得ることができます。 length(x) ## [1] 50 このベクトルを用いて，いろいろな計算ができます。 合計を計算するには sum() を使います。 sum(x) ## [1] 2500 これはExcelの関数として使ったことがあるのではないでしょうか。 平均は次のようにして計算します。 mean(x) ## [1] 50 こうした関数を数式に含めることもできます。 x - mean(x) ## [1] -49 -47 -45 -43 -41 -39 -37 -35 -33 -31 -29 -27 -25 -23 -21 -19 -17 -15 -13 ## [20] -11 -9 -7 -5 -3 -1 1 3 5 7 9 11 13 15 17 19 21 23 25 ## [39] 27 29 31 33 35 37 39 41 43 45 47 49 上では変数名は何でもよいとしましたが，すでに定義されている予約語は使用してはいけません。 次のコマンドを実行することで，予約語を知ることができます。 ?reserved 予約語ではない変数名にするように心掛けましょう。 1.2.5 パッケージ Rをインストールした素の状態で使える関数は限られています。 Rユーザーが有益な関数を作成し，他のユーザーと共有しているものがあります。 これらの関数は，パッケージとしてCRANに公開されており，それを自分のパソコンにインストールできます。 1.2.5.1 パッケージのインストール 例えば，Microsoft Excelで作成されたファイルを効率的に読むことができる readxl パッケージを使う場合を考えます。 このパッケージを初めて使う場合のみ，自分のパソコンにパッケージをインストールする必要があります（Rのバージョンが変わったときにもパッケージをインストールする必要があります）。 以下のコマンドを実行すれば，目的のパッケージがインストールされます。 install.packages(&quot;readxl&quot;) このコマンドは一度実行すれば，Rを終了しても，また，パソコンの電源を切ったとしても，再度実行する必要はありません。 実行してもエラーにはならないので，不安なら実行して構いませんが，一度インストールしたパッケージはパソコンの中に残ります。 さて，readxl パッケージの中の関数 read_excel() を使ってみましょう。 使い方を知るために，ヘルプを見てみます。 ?read_excel ## 指定されたパッケージやライブラリ中には &#39;read_excel&#39; に対するドキュメントはありません ## &#39;??read_excel&#39; を使えたかもしれません おや，ヘルプのウィンドウではなく，何かメッセージが出てきました。 メッセージに従って，次のコマンドを実行してみます。 ??read_excel どうなりましたか？ ウェブブラウザが開き，次の文字が表示されたはずです。 readxl::read_excel Read xls and xlsx files ここに書いてあることを理解しましょう。 左にあるのが，パッケージ名と関数名で，それぞれが :: で結ばれています。 ここでは，readxl というパッケージの中に関数 read_excel() があるということを意味しています。 右側には，その関数がどのようなものかが書かれています。 この記述により，readxl というパッケージの中の関数 read_excel() は，xlsとxlsx（Excelファイルの拡張子）を読む関数であることがわかります。 ちなみに，この例の readxl:: の部分を名前空間と呼びますが，通常知らなくてよいです。 （:: の前に記述されている）パッケージの中の（:: の後に記述されている）関数というように，関数の由来を明示したいときにこのような表記をします。 めったにないことですが，異なるパッケージで同じ関数があるときに，どちらの関数を使うのかを明示する必要があります。 初心者のうちは，自らこういった書き方をする必要はありません。 1.2.5.2 パッケージのロード インストールしたパッケージをRで使えるようにするためには，目的のパッケージをRにロードする必要があります。 パッケージをロードするには，次のコマンドを用います。 library(readxl) このとき，以下のようにしても構いません。 library(&quot;readxl&quot;) つまり，install.packages() のときは，\"\" で括らなければなりませんが，library() の場合はどちらでも構いません。 ちなみに，何もしなくても最初からロードされているパッケージがいくつかあります。 その場合，そのパッケージをロードしなくても，そのパッケージに含まれる関数を使うことができます。 どういったパッケージが最初からロードされているかは，使っているうちに理解できると思います。 インストールしたパッケージの関数を使う場合，いま仮に \"sample.xlsx\" という名前のExcelファイルがあるとすると，以下のコマンドを実行します。 read_excel(&quot;sample.xlsx&quot;) このコマンドは，次のように名前空間を付けて書くこともできますが，多くの場合，そうする必要はありません。 readxl::read_excel(&quot;sample.xlsx&quot;) 1.2.5.3 CRAN以外からのパッケージのインストール CRANに登録されていないパッケージもインストールできる場合があります。 例えば，日本語形態素解析器MeCabのRラッパーである RMeCab パッケージをインストールする方法は次のリンク先に書かれています。 RMeCab: Interface to MeCab その他にも GitHub からパッケージをインストールできることもあります。 CRAN以外からのパッケージのインストール方法については，各パッケージの説明に従ってください。 1.2.5.4 パッケージのアップデート パッケージにはバージョンがあり，常に最新のバージョンを使うべきです。 古いバージョンにはバグがあったり，正しい結果が得られない場合があります。 インストールされているパッケージは自動でアップデートされないため，定期的に次のコマンドを実行するように心掛けましょう。 update.packages(ask = FALSE) なお，アップデートはマウス（またはトラックパッド）だけでも操作できます。 Windowsの場合は，メニューの「パッケージ」から「パッケージの更新…」を選択します。 macOSの場合は，メニューの「パッケージとデータ」から「パッケージインストーラ」を選択し，「すべてアップデート」を選択します。 いずれのOSでも，CRANのミラーサイトの選択画面が出たときは，選択肢の中からどれか1つのサイトを選択してください。 どれを選べばよいかわからない場合は，日本のサイトを選択することをおすすめします。 1.2.5.5 パッケージの一覧表示 インストールされているパッケージの一覧は次のコマンドで得られます。 .packages(all.available = TRUE) ただし，これは知らなくてもよいです。 また，パッケージがどこにインストールされているかを知りたい場合は，次のコマンドを実行します。 searchpaths() これも知らなくてよいです。 もし何らかの理由で，CRANに公開されているパッケージをすべてインストールしたい場合は，以下のコマンドを実行します。 installed &lt;- row.names(installed.packages()) available &lt;- row.names(available.packages()) uninstalled &lt;- available[!available %in% installed] install.packages(uninstalled) ただし，来週から数ヶ月間インターネット環境のない場所に行くといった特別な理由がない限り，このような操作は必要ありません。 非常に時間がかかりますし，SSDも大量に消費します。 1.2.5.6 パッケージのアンインストール なお，これも使う機会はないと思いますが，特定のパッケージをアンインストールしたい場合は，以下のコマンドを実行します。 remove.packages(&quot;パッケージ名&quot;) 1.3 練習問題 1から10までの数字を足し算するといくらになるか計算しなさい。 1から10までの数字の平均を求めなさい。 1000以上2000以下のうち，偶数の値を合計しなさい。 1から15までの数列の累積和を計算し、それぞれの値を表示しなさい。累積和とは、数列の各位置までの合計を計算した結果です。 "],["2-基礎.html", "2 基礎 2.1 データの型 2.2 データの構造 2.3 特殊記号 2.4 入門書 2.5 練習問題", " 2 基礎 今回は，前回の練習問題の解答について解説しつつ，Rの基礎を学びます。 とくにデータの型と構造について理解しておかなければなりません。 Rを使うとき，常に，「このコードを実行するとこうなるはずだ」と予想してください。 予想通りの結果が得られた場合，自分の予想は正しかったことが確かめられます。 予想とは異なる結果が得られた場合，2つの原因が考えられます。 予想の元となった自分の考えが間違っていた。 コードが間違っている。 どちらが原因で予想と異なる結果が得られたかを考えてください。 前者の場合は自分の考えを改める必要があります。 Rの学習は，この予想と結果を合わせていく作業です。 常に，予想した結果が得られなければなりません。 2.1 データの型 データの型には，数値，文字列，ファクター（因子），論理値があります。 以下のどれかのコマンドを使って，そのデータの型を知ることができます。 typeof() mode() class() ただし，常に意識するというよりは，エラーの原因追及（バグフィックス）時に必要な知識です。 このため，自分が書いたスクリプトにバグが入らないようにしたいなら，このデータの型を意識しておかなければなりません。 データの型には次の種類があります。 実数 整数 文字列 ファクター 論理値 2.1.1 数値 実数と整数はいずれも数値で，区別しなくても困りません。 数値は計算できます。 任意のオブジェクトが数値かどうかを判定したいときは，is.double() または is.numeric() を用います。 x &lt;- 10 is.double(x) ## [1] TRUE # is.numeric(x) 返り値の TRUE は真という意味で，判定（知りたいこと）が真のときに TRUE が返ってきます。 Rではデフォルトで数値は実数として扱われます。 数字を扱うにあたって，それ以上のことを考える必要はありません。 もし整数として明示的に扱いたい場合は，次の関係を知っておいてください。 x &lt;- 10 is.integer(x) ## [1] FALSE x &lt;- 10L is.integer(x) ## [1] TRUE x &lt;- as.integer(10) is.integer(x) ## [1] TRUE また，整数は整数として意識的に維持しなければ，容易に実数に変化します。 10L + 2; is.integer(10L + 2) ## [1] 12 ## [1] FALSE 10L + 2L; is.integer(10L + 2L) ## [1] 12 ## [1] TRUE 多くの場合，数値を扱いたい場合は，整数ではなく，実数を使って問題ありません。 2.1.2 文字列 文字列は文字として表現されるもので，\"\" で括って表記します。 c(&quot;a&quot;, &quot;あ&quot;, &#39;b&#39;) ## [1] &quot;a&quot; &quot;あ&quot; &quot;b&quot; 多くの場合，\"\" は '' で代替できます。 ただし，Rの返り値は必ず \"\" で括られますので，'' ではなく \"\" を使うようにしてください。 c(&quot;a&quot;, &quot;あ&quot;, &quot;b&quot;) ## [1] &quot;a&quot; &quot;あ&quot; &quot;b&quot; 文字列の中に \" を入れたい場合に '' を使うとよいです。 x &lt;- &#39;&quot;あ&quot;&#39; x ## [1] &quot;\\&quot;あ\\&quot;&quot; 返り値がおかしいですね。 いや，これでいいのです。 \\ のことをエスケープシーケンスと呼びます。 エスケープシーケンスを使うと，文字列は常に \"\" で括れます。 x &lt;- &quot;\\&quot;あ\\&quot;&quot; x ## [1] &quot;\\&quot;あ\\&quot;&quot; 文字列をくっつける関数に paste() があります。 次のように使います。 x &lt;- &quot;愛媛&quot; y &lt;- &quot;県&quot; paste(x, y) ## [1] &quot;愛媛 県&quot; デフォルトでは結合部分に半角スペースが入ります。 結合部分に入れる文字は，引数 sep で指定します。 何も入れたくない場合は，次のようにします。 paste(x, y, sep = &quot;&quot;) ## [1] &quot;愛媛県&quot; 数値を文字列に変換する場合は，as.character() を使います。 ただし，paste() の方が便利なため，paste() を頻繁に使うことになるでしょう。 例えば次のようにします。 paste(2000:2010, &quot;年&quot;, sep = &quot;&quot;) ## [1] &quot;2000年&quot; &quot;2001年&quot; &quot;2002年&quot; &quot;2003年&quot; &quot;2004年&quot; &quot;2005年&quot; &quot;2006年&quot; &quot;2007年&quot; ## [9] &quot;2008年&quot; &quot;2009年&quot; &quot;2010年&quot; paste() は文字列を繋げる関数です。 引数には文字列を取りますので，引数に数値がある場合は，勝手に文字列に変換されます。 2.1.3 ファクター ファクターは見た目は文字列ですが，以下の特徴があります。 取り得る値の数が有限である。 グループ分けに使える。 値に順番のようなものがある。 例えば，学生の成績は「秀」「優」「良」「可」「不可」で表現されます。 あるいは，「S」「A」「B」「C」「D」といった表現もあります。 これらの文字列には順番があります。 「秀」は「優」より上，「優」は「良」より上です。 また，「愛媛県」は文字列で，一見順番は関係なさそうですが，都道府県コードというものが割り振られており，都道府県別に並べるとき，愛媛県は38番目に表示するというルールがあります。 「北海道」が01で，「沖縄県」が47です。 他に，アンケート調査の選択のある問に対する解答として，「強くそう思う」「ややそう思う」「どちらでもない」「あまりそう思わない」「まったくそう思わない」といったデータがあり得ます。 こうしたデータを扱う場合，ファクターを文字列として考えていると，思い通りの表示にならなかったり，処理できずエラーが返ってくることがあります。 次のデータがあったとします。 grade &lt;- c(&quot;優&quot;, &quot;良&quot;, &quot;可&quot;, &quot;良&quot;, &quot;良&quot;, &quot;不可&quot;, &quot;秀&quot;, &quot;優&quot;, &quot;可&quot;, &quot;良&quot;) grade ## [1] &quot;優&quot; &quot;良&quot; &quot;可&quot; &quot;良&quot; &quot;良&quot; &quot;不可&quot; &quot;秀&quot; &quot;優&quot; &quot;可&quot; &quot;良&quot; この変数 grade に順番のようなものを持たせるためには，次のようにします。 grade2 &lt;- factor(grade, levels = c(&quot;不可&quot;, &quot;可&quot;, &quot;良&quot;, &quot;優&quot;, &quot;秀&quot;)) grade2 ## [1] 優 良 可 良 良 不可 秀 優 可 良 ## Levels: 不可 可 良 優 秀 ファクターの返り値に順番が Levels として表記されます。 この Levels はファクターに付けられたラベルであり，次のコマンドで取り出せます。 levels(grade2) ## [1] &quot;不可&quot; &quot;可&quot; &quot;良&quot; &quot;優&quot; &quot;秀&quot; ファクターのラベルを変更すれば，ファクターの各要素の値も変わります。 levels(grade2) &lt;- c(&quot;D&quot;, &quot;C&quot;, &quot;B&quot;, &quot;A&quot;, &quot;S&quot;) grade2 ## [1] A B C B B D S A C B ## Levels: D C B A S ファクターを文字列に変換すれば，ラベル（順番の情報）は失われます。 as.character(grade2) ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;B&quot; &quot;B&quot; &quot;D&quot; &quot;S&quot; &quot;A&quot; &quot;C&quot; &quot;B&quot; 上述の説明は順番のようなものの存在を暗黙裏に扱っており，通常の使用ではこれで問題ありません。 もし明示的に順番を扱いたい場合は，次のようにする必要があります。 factor(grade, levels = c(&quot;不可&quot;, &quot;可&quot;, &quot;良&quot;, &quot;優&quot;, &quot;秀&quot;), ordered = TRUE) ## [1] 優 良 可 良 良 不可 秀 優 可 良 ## Levels: 不可 &lt; 可 &lt; 良 &lt; 優 &lt; 秀 また，上述のアンケート調査の例では，実際は，ファクターではなく，数値に変換して分析することもあります。 x &lt;- factor(grade, levels = c(&quot;不可&quot;, &quot;可&quot;, &quot;良&quot;, &quot;優&quot;, &quot;秀&quot;)) as.double(x) ## [1] 4 3 2 3 3 1 5 4 2 3 2.1.4 論理値 オブジェクトの状態を表すものに，TRUE と FALSE があります。 日本語では，TRUE は真で，FALSE で偽と表現します。 これまで関数の引数として登場しました。 TRUE は T と省略でき，FALSE は F と省略できることを知っておいてください。 ただし，自分では T や F を使わないでください。 複雑なコードのときに，T や F よりも，TRUE や FALSE の方が分かりやすいからです。 もしどこかでT や F を見かけたら，頭の中でそれぞれ TRUE と FALSE に置き換えてください。 なお，True や true ではなく，必ず大文字を使ってください。 論理値は，真偽を確かめたいときに関数の返り値として用いられます。 このとき，論理値が計算できることを知っておくと役に立つ場面がある。 x &lt;- rep(TRUE, 10) x ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE sum(x) ## [1] 10 この例のように，TRUE のベクトルをわざわざ生成することは実際はあまりありませんが，比較演算子を用いた判定の返り値を計算に利用することはよくあります。 このとき，sum() は TRUE の数に一致します。 つまり，TRUE の数を数えていると理解してもよいです。 実際には，R内部で TRUE は数値の 1 に変換され，FALSE は数値の 0 に変換された後，sum() が適用されています。 2.2 データの構造 データの構造には以下の種類のものがあります。 ベクトル 行列 データフレーム リスト 2.2.1 ベクトル ベクトルは，c() で作成します。 c(10, 12, 15, 20) ## [1] 10 12 15 20 seq() などの関数のように，返り値がベクトルとなるものもあります。 ベクトルの四則演算はベクトルを返します。 c(10, 12, 15, 20) * 5 ## [1] 50 60 75 100 列ベクトルか行ベクトルかはあまり気にする必要はありません。 ベクトルの転置は次のようにします。 x &lt;- 1990:2020 x ## [1] 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 ## [16] 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 ## [31] 2020 t(x) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14] ## [1,] 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 ## [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] [,26] ## [1,] 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 ## [,27] [,28] [,29] [,30] [,31] ## [1,] 2016 2017 2018 2019 2020 このことから，x と x を転置した t(x) は違うことが分かります。 ベクトルは数値である必要はなく，文字列のベクトルも作成できます。 c(&quot;テニス&quot;, &quot;バレーボール&quot;, &quot;野球&quot;, &quot;サッカー&quot;) ## [1] &quot;テニス&quot; &quot;バレーボール&quot; &quot;野球&quot; &quot;サッカー&quot; ただし，ベクトルの各要素の型は同じでなければなりません。 例えば，数値と文字列を混ぜた場合，そのベクトルは文字列になります。 x &lt;- c(1, &quot;テニス&quot;, 3) x[1] + x[3] ## Error in x[1] + x[3]: 二項演算子の引数が数値ではありません 文字列は，たとえ見た目が数値であったとしても，計算できません。 文字列は必ず \"\" で括られています。 x ## [1] &quot;1&quot; &quot;テニス&quot; &quot;3&quot; ただし，文字列の中が数値の場合，その文字列は数値に変換できます。 文字列を数値に変換する場合は，as.double() を用います。 as.double(x[1]) + as.double(x[3]) ## [1] 4 次のように，as.numeric() でも同じ結果が得られますが，文字列を数値に変換する場合，as.double() を使う方が（おそらく）正当なやり方です。 as.numeric(x[1]) + as.numeric(x[3]) ## [1] 4 2.2.1.1 欠損値 データがない部分のことを欠損値と言います。 数値の欠損値は NA で表します。 例えば，アンケート調査を実施して，ある回答者がある問の選択問題の解答をしていない場合，そこに - を入力してはいけません。 そこには，何も入力しないのが正しいデータ作成の方法です。 Microsoft Excelでデータ入力する場合は，そのセルには何も入力せずに次の入力に移ってください。 ただし，Rでデータ作成する場合，次のようにするとエラーが返ってきます。 c(1, 2, , 4, 5) このため，欠損値には NA と書いてください。 c(1, 2, NA, 4, 5) CSVファイルなどをRで読み込むときに欠損値があると，その部分がデフォルトでは NA に置き換わります。 ここで，次のようにするとエラーが返ってきます。 c(1, 2, -, 4, 5) また，次のようにすると全体が文字列になります。 c(1, 2, &quot;-&quot;, 4, 5) 一方，アンケート調査で，文章で回答してもらう問に対して無回答だった場合，そこに \"\" を入力してください。 Microsoft Excelでデータ入力する場合は，そのセルには何も入力せずに次の入力に移ってください。 CSVファイルなどをRで読み込むときに欠損値があると，その部分がデフォルトでは \"\" に置き換わります。 c(&quot;テニスが好き&quot;, &quot;バレーボールをやってた&quot;, NA, &quot;野球が苦手&quot;, &quot;サッカーが得意&quot;) これだとエラーは返ってきませんが，あまりよい方法ではありません。 この場合，次のようにしてください。 c(&quot;テニスが好き&quot;, &quot;バレーボールをやってた&quot;, &quot;&quot;, &quot;野球が苦手&quot;, &quot;サッカーが得意&quot;) NA に似たものに NULL があります。 NULL はデータの欠損値には使いません。 NULL には例えば次のような使い方があります。 x &lt;- NULL 2.2.2 名前付きベクトル 名前付きベクトルというものがあります。 辞書のような働きをします。 あまり使わないので，ここでは説明を省略します。 2.2.3 行列 Rは行列計算が高速であることが特徴のひとつです。 また，ここには書きませんが，行列を用いた数式の表記は簡潔です。 行列は以下のようにして作成します。 matrix(1:12, nrow = 4) ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 nrow は行の数です。 行列の要素の数は，nrow の値で割り切れなければなりません。 列の数 ncol を指定しても構いません。 行列の外側の []で囲まれた部分に注目してください。 [] と , と数字によって，そこが行列の何行目か，あるいは，何列目かが分かります。 [行, 列] という関係になっています。 行列はMicrosoft Excelでよく見る表に似ていますが，そうではなく，数学で出てくる行列そのものだと理解してください。 行列の要素は [] を用いて取り出します。 例えば，1行2列の要素は次のようにして取り出します。 x &lt;- matrix(1:12, nrow = 4) x[1, 2] ## [1] 5 行は次のようにして取り出します。 x[2, ] ## [1] 2 6 10 列は次のようにして取り出します。 x[, 3] ## [1] 9 10 11 12 この法則に従って，スペースを入れることを忘れないようにしてください（スペースを入れなくてもエラーは出ません）。 2.2.3.1 Tips 行列はベクトルを折り畳んだようなものであると理解しておくと役に立つことがあります。 次の結果を比較して，行列がベクトルであることを理解してください。 matrix(1:12, nrow = 4)[5] ## [1] 5 matrix(1:12, nrow = 4, byrow = TRUE)[5] ## [1] 2 ただし，通常のデータ分析で行列を扱う機会は少ないかもしれません。 次のコマンドが FALSE を返すように，厳密にはベクトルではありません。 is.vector(matrix(1:12, nrow = 4)) ## [1] FALSE しかし，ベクトルであるかのように動作することがあります。 2.2.4 データフレーム データフレームはMicrosoft Excelでよく見る表に似ており，そのようなものだと理解してください。 read.csv() で読み込んだオブジェクトは，データフレームです。 データフレームには行と列が存在する点では，行列に似ています。 しかしながら，行列とは違い，各列を異なる型にすることができることから，行列よりも柔軟なデータ構造となります。 それぞれの列は同じ型でなければなりません。 Rには最初から多くのデータセットが使える状態になっています。 サンプルとしてよく使われるデータセットに iris があります。 iris の中身は，iris と入力するだけで表示されます。 iris データフレームの全体を表示させることなく，データフレームの構造を知りたいときは，最初の数行を表示させるコマンドを使うのが便利です。 head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa 同じように，最後の数行を表示させることもできます。 tail(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 145 6.7 3.3 5.7 2.5 virginica ## 146 6.7 3.0 5.2 2.3 virginica ## 147 6.3 2.5 5.0 1.9 virginica ## 148 6.5 3.0 5.2 2.0 virginica ## 149 6.2 3.4 5.4 2.3 virginica ## 150 5.9 3.0 5.1 1.8 virginica 途中の行を表示させたい場合は，行番号を指定します。 iris[100:105, ] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 100 5.7 2.8 4.1 1.3 versicolor ## 101 6.3 3.3 6.0 2.5 virginica ## 102 5.8 2.7 5.1 1.9 virginica ## 103 7.1 3.0 5.9 2.1 virginica ## 104 6.3 2.9 5.6 1.8 virginica ## 105 6.5 3.0 5.8 2.2 virginica iris は変数であり，次のコマンドで確かめられるように，データフレームです。 is.data.frame(iris) ## [1] TRUE データフレームの構造を知りたい場合は，次のようにします。 str(iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... データフレームを90度左に回転して反転させた表示になっていることに気づいたのではないでしょうか。 iris の1列目 Sepal.Length が一番上に表示されています。 iris の2列目は2行目というように順番に表示されます。 また，データフレームの列ごとにデータの型（の省略形）が表示されることが分かります。 すなわち，データフレームのどの列もデータの型は1つしか認められていません。 違う型の行を追加しようとすると，エラーになるか警告が表示されます。 行の数と列の数は次のコマンドで取得できます。 dim(iris) ## [1] 150 5 この情報は，str(iris) の1行目に表示されるものと同じです。 なお，データフレームを Excel のように表示したい場合は，次のコマンドを実行します。 View(iris) macOS では XQuartz が起動します。 R に慣れるまで，データフレームを Excel のような表示にした方が分かりやすい場合は View() を使ってください。 そのうち，必要なくなると思います。 2.2.4.1 データフレームの列 データフレームそのものを分析に使うこともできますが，必要な列を取り出して，分析に使うのが一般的です。 そこで，データフレームの列を取り出す方法をいくつか説明します。 なお，データフレームの進化したものに，tibble があります。 tibbleはデータフレームとほとんど同じように扱えますが，データフレームとは挙動が若干異なりますので，違うものと考えてください。 ちなみに，read_excel() で読み込んだオブジェクトは，tibbleです。 tibbleは Tidyverse の一部分（最も重要な部分）を構成します。 データフレームの列を取り出す場合，左から何列目であるかを数値で指定することができます。 次のコマンドにより，データフレームの列をベクトルとして取り出すことができます。 iris[, 1] ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 5.7 ## [20] 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 5.5 4.9 ## [39] 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 6.5 5.7 6.3 ## [58] 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 ## [77] 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 5.5 6.1 5.8 5.0 5.6 ## [96] 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 ## [115] 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 ## [134] 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 6.7 6.7 6.3 6.5 6.2 5.9 返り値をデータフレームとして保ちたければ，次のようにします。 iris[1] ## Sepal.Length ## 1 5.1 ## 2 4.9 ## 3 4.7 ## 4 4.6 ## 5 5.0 ## 6 5.4 ## 7 4.6 ## 8 5.0 ## 9 4.4 ## 10 4.9 ## 11 5.4 ## 12 4.8 ## 13 4.8 ## 14 4.3 ## 15 5.8 ## 16 5.7 ## 17 5.4 ## 18 5.1 ## 19 5.7 ## 20 5.1 ## 21 5.4 ## 22 5.1 ## 23 4.6 ## 24 5.1 ## 25 4.8 ## 26 5.0 ## 27 5.0 ## 28 5.2 ## 29 5.2 ## 30 4.7 ## 31 4.8 ## 32 5.4 ## 33 5.2 ## 34 5.5 ## 35 4.9 ## 36 5.0 ## 37 5.5 ## 38 4.9 ## 39 4.4 ## 40 5.1 ## 41 5.0 ## 42 4.5 ## 43 4.4 ## 44 5.0 ## 45 5.1 ## 46 4.8 ## 47 5.1 ## 48 4.6 ## 49 5.3 ## 50 5.0 ## 51 7.0 ## 52 6.4 ## 53 6.9 ## 54 5.5 ## 55 6.5 ## 56 5.7 ## 57 6.3 ## 58 4.9 ## 59 6.6 ## 60 5.2 ## 61 5.0 ## 62 5.9 ## 63 6.0 ## 64 6.1 ## 65 5.6 ## 66 6.7 ## 67 5.6 ## 68 5.8 ## 69 6.2 ## 70 5.6 ## 71 5.9 ## 72 6.1 ## 73 6.3 ## 74 6.1 ## 75 6.4 ## 76 6.6 ## 77 6.8 ## 78 6.7 ## 79 6.0 ## 80 5.7 ## 81 5.5 ## 82 5.5 ## 83 5.8 ## 84 6.0 ## 85 5.4 ## 86 6.0 ## 87 6.7 ## 88 6.3 ## 89 5.6 ## 90 5.5 ## 91 5.5 ## 92 6.1 ## 93 5.8 ## 94 5.0 ## 95 5.6 ## 96 5.7 ## 97 5.7 ## 98 6.2 ## 99 5.1 ## 100 5.7 ## 101 6.3 ## 102 5.8 ## 103 7.1 ## 104 6.3 ## 105 6.5 ## 106 7.6 ## 107 4.9 ## 108 7.3 ## 109 6.7 ## 110 7.2 ## 111 6.5 ## 112 6.4 ## 113 6.8 ## 114 5.7 ## 115 5.8 ## 116 6.4 ## 117 6.5 ## 118 7.7 ## 119 7.7 ## 120 6.0 ## 121 6.9 ## 122 5.6 ## 123 7.7 ## 124 6.3 ## 125 6.7 ## 126 7.2 ## 127 6.2 ## 128 6.1 ## 129 6.4 ## 130 7.2 ## 131 7.4 ## 132 7.9 ## 133 6.4 ## 134 6.3 ## 135 6.1 ## 136 7.7 ## 137 6.3 ## 138 6.4 ## 139 6.0 ## 140 6.9 ## 141 6.7 ## 142 6.9 ## 143 5.8 ## 144 6.8 ## 145 6.7 ## 146 6.7 ## 147 6.3 ## 148 6.5 ## 149 6.2 ## 150 5.9 次のようにすると，左から1列目をベクトルとして取り出せます。 iris[[1]] ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 5.7 ## [20] 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 5.5 4.9 ## [39] 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 6.5 5.7 6.3 ## [58] 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 ## [77] 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 5.5 6.1 5.8 5.0 5.6 ## [96] 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 ## [115] 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 ## [134] 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 6.7 6.7 6.3 6.5 6.2 5.9 このことから，iris[, 1] と iris[[1]] は同じ結果が得られることが分かります。 データフレームの左から何列目かという情報は，対話的にRを使う場合は便利なときもありますが，データフレームの構造を正確に把握しておかなければならず，またデータフレームの列が多くなった場合，何列目かをわざわざ数えなければなりません。 こうした作業は面倒だということもありますが，それ以上に，間違う可能性があります。 列を取り出す際，データフレームの左から何列目かという情報ではなく，列名で指定する方が間違いが少なくなるでしょう。 iris の Sepal.Length 列を取り出したい場合は，次のように $ で繋ぎます。 iris$Sepal.Length ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 5.7 ## [20] 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 5.5 4.9 ## [39] 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 6.5 5.7 6.3 ## [58] 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 ## [77] 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 5.5 6.1 5.8 5.0 5.6 ## [96] 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 ## [115] 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 ## [134] 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 6.7 6.7 6.3 6.5 6.2 5.9 列名が日本語の場合など，次のようにしなければエラーが返ってくることがあります。 iris$`Sepal.Length` 日本語の他にも，列名に () が使われている場合は，`` で括らなければエラーが返ってきます。 返り値をデータフレームとして保ちたければ，次のようにします。 iris[&quot;Sepal.Length&quot;] ## Sepal.Length ## 1 5.1 ## 2 4.9 ## 3 4.7 ## 4 4.6 ## 5 5.0 ## 6 5.4 ## 7 4.6 ## 8 5.0 ## 9 4.4 ## 10 4.9 ## 11 5.4 ## 12 4.8 ## 13 4.8 ## 14 4.3 ## 15 5.8 ## 16 5.7 ## 17 5.4 ## 18 5.1 ## 19 5.7 ## 20 5.1 ## 21 5.4 ## 22 5.1 ## 23 4.6 ## 24 5.1 ## 25 4.8 ## 26 5.0 ## 27 5.0 ## 28 5.2 ## 29 5.2 ## 30 4.7 ## 31 4.8 ## 32 5.4 ## 33 5.2 ## 34 5.5 ## 35 4.9 ## 36 5.0 ## 37 5.5 ## 38 4.9 ## 39 4.4 ## 40 5.1 ## 41 5.0 ## 42 4.5 ## 43 4.4 ## 44 5.0 ## 45 5.1 ## 46 4.8 ## 47 5.1 ## 48 4.6 ## 49 5.3 ## 50 5.0 ## 51 7.0 ## 52 6.4 ## 53 6.9 ## 54 5.5 ## 55 6.5 ## 56 5.7 ## 57 6.3 ## 58 4.9 ## 59 6.6 ## 60 5.2 ## 61 5.0 ## 62 5.9 ## 63 6.0 ## 64 6.1 ## 65 5.6 ## 66 6.7 ## 67 5.6 ## 68 5.8 ## 69 6.2 ## 70 5.6 ## 71 5.9 ## 72 6.1 ## 73 6.3 ## 74 6.1 ## 75 6.4 ## 76 6.6 ## 77 6.8 ## 78 6.7 ## 79 6.0 ## 80 5.7 ## 81 5.5 ## 82 5.5 ## 83 5.8 ## 84 6.0 ## 85 5.4 ## 86 6.0 ## 87 6.7 ## 88 6.3 ## 89 5.6 ## 90 5.5 ## 91 5.5 ## 92 6.1 ## 93 5.8 ## 94 5.0 ## 95 5.6 ## 96 5.7 ## 97 5.7 ## 98 6.2 ## 99 5.1 ## 100 5.7 ## 101 6.3 ## 102 5.8 ## 103 7.1 ## 104 6.3 ## 105 6.5 ## 106 7.6 ## 107 4.9 ## 108 7.3 ## 109 6.7 ## 110 7.2 ## 111 6.5 ## 112 6.4 ## 113 6.8 ## 114 5.7 ## 115 5.8 ## 116 6.4 ## 117 6.5 ## 118 7.7 ## 119 7.7 ## 120 6.0 ## 121 6.9 ## 122 5.6 ## 123 7.7 ## 124 6.3 ## 125 6.7 ## 126 7.2 ## 127 6.2 ## 128 6.1 ## 129 6.4 ## 130 7.2 ## 131 7.4 ## 132 7.9 ## 133 6.4 ## 134 6.3 ## 135 6.1 ## 136 7.7 ## 137 6.3 ## 138 6.4 ## 139 6.0 ## 140 6.9 ## 141 6.7 ## 142 6.9 ## 143 5.8 ## 144 6.8 ## 145 6.7 ## 146 6.7 ## 147 6.3 ## 148 6.5 ## 149 6.2 ## 150 5.9 このとき，\"\" をつけなければエラーが返ってきます。 ここで，\"\" の中は文字列として扱われるため，`` で括る必要はありません。 iris[Sepal.Length] ## Error: オブジェクト &#39;Sepal.Length&#39; がありません このとき，Sepal.Length という名前の変数（オブジェクト）を探しに行き，それがないためエラーを返しています。 次のようにすると，ベクトルとして取り出せます。 iris[[&quot;Sepal.Length&quot;]] ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 5.7 ## [20] 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 5.5 4.9 ## [39] 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 6.5 5.7 6.3 ## [58] 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 ## [77] 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 5.5 6.1 5.8 5.0 5.6 ## [96] 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 ## [115] 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 ## [134] 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 6.7 6.7 6.3 6.5 6.2 5.9 ここで，列名を知るにはどうすればよいでしょうか。 str() で知ることができますが，str() だと情報が多いです。 データフレームの列名のみを得るには，次のコマンドを用います。 names(iris) ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; &quot;Species&quot; これは次のようにしても同じです。 colnames(iris) ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; &quot;Species&quot; 次に，複数の列を取り出してみます。 iris の Sepal.Length 列と Sepal.Width 列を取り出すには，次のようにします。 iris[c(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;)] ## Sepal.Length Sepal.Width ## 1 5.1 3.5 ## 2 4.9 3.0 ## 3 4.7 3.2 ## 4 4.6 3.1 ## 5 5.0 3.6 ## 6 5.4 3.9 ## 7 4.6 3.4 ## 8 5.0 3.4 ## 9 4.4 2.9 ## 10 4.9 3.1 ## 11 5.4 3.7 ## 12 4.8 3.4 ## 13 4.8 3.0 ## 14 4.3 3.0 ## 15 5.8 4.0 ## 16 5.7 4.4 ## 17 5.4 3.9 ## 18 5.1 3.5 ## 19 5.7 3.8 ## 20 5.1 3.8 ## 21 5.4 3.4 ## 22 5.1 3.7 ## 23 4.6 3.6 ## 24 5.1 3.3 ## 25 4.8 3.4 ## 26 5.0 3.0 ## 27 5.0 3.4 ## 28 5.2 3.5 ## 29 5.2 3.4 ## 30 4.7 3.2 ## 31 4.8 3.1 ## 32 5.4 3.4 ## 33 5.2 4.1 ## 34 5.5 4.2 ## 35 4.9 3.1 ## 36 5.0 3.2 ## 37 5.5 3.5 ## 38 4.9 3.6 ## 39 4.4 3.0 ## 40 5.1 3.4 ## 41 5.0 3.5 ## 42 4.5 2.3 ## 43 4.4 3.2 ## 44 5.0 3.5 ## 45 5.1 3.8 ## 46 4.8 3.0 ## 47 5.1 3.8 ## 48 4.6 3.2 ## 49 5.3 3.7 ## 50 5.0 3.3 ## 51 7.0 3.2 ## 52 6.4 3.2 ## 53 6.9 3.1 ## 54 5.5 2.3 ## 55 6.5 2.8 ## 56 5.7 2.8 ## 57 6.3 3.3 ## 58 4.9 2.4 ## 59 6.6 2.9 ## 60 5.2 2.7 ## 61 5.0 2.0 ## 62 5.9 3.0 ## 63 6.0 2.2 ## 64 6.1 2.9 ## 65 5.6 2.9 ## 66 6.7 3.1 ## 67 5.6 3.0 ## 68 5.8 2.7 ## 69 6.2 2.2 ## 70 5.6 2.5 ## 71 5.9 3.2 ## 72 6.1 2.8 ## 73 6.3 2.5 ## 74 6.1 2.8 ## 75 6.4 2.9 ## 76 6.6 3.0 ## 77 6.8 2.8 ## 78 6.7 3.0 ## 79 6.0 2.9 ## 80 5.7 2.6 ## 81 5.5 2.4 ## 82 5.5 2.4 ## 83 5.8 2.7 ## 84 6.0 2.7 ## 85 5.4 3.0 ## 86 6.0 3.4 ## 87 6.7 3.1 ## 88 6.3 2.3 ## 89 5.6 3.0 ## 90 5.5 2.5 ## 91 5.5 2.6 ## 92 6.1 3.0 ## 93 5.8 2.6 ## 94 5.0 2.3 ## 95 5.6 2.7 ## 96 5.7 3.0 ## 97 5.7 2.9 ## 98 6.2 2.9 ## 99 5.1 2.5 ## 100 5.7 2.8 ## 101 6.3 3.3 ## 102 5.8 2.7 ## 103 7.1 3.0 ## 104 6.3 2.9 ## 105 6.5 3.0 ## 106 7.6 3.0 ## 107 4.9 2.5 ## 108 7.3 2.9 ## 109 6.7 2.5 ## 110 7.2 3.6 ## 111 6.5 3.2 ## 112 6.4 2.7 ## 113 6.8 3.0 ## 114 5.7 2.5 ## 115 5.8 2.8 ## 116 6.4 3.2 ## 117 6.5 3.0 ## 118 7.7 3.8 ## 119 7.7 2.6 ## 120 6.0 2.2 ## 121 6.9 3.2 ## 122 5.6 2.8 ## 123 7.7 2.8 ## 124 6.3 2.7 ## 125 6.7 3.3 ## 126 7.2 3.2 ## 127 6.2 2.8 ## 128 6.1 3.0 ## 129 6.4 2.8 ## 130 7.2 3.0 ## 131 7.4 2.8 ## 132 7.9 3.8 ## 133 6.4 2.8 ## 134 6.3 2.8 ## 135 6.1 2.6 ## 136 7.7 3.0 ## 137 6.3 3.4 ## 138 6.4 3.1 ## 139 6.0 3.0 ## 140 6.9 3.1 ## 141 6.7 3.1 ## 142 6.9 3.1 ## 143 5.8 2.7 ## 144 6.8 3.2 ## 145 6.7 3.3 ## 146 6.7 3.0 ## 147 6.3 2.5 ## 148 6.5 3.0 ## 149 6.2 3.4 ## 150 5.9 3.0 データフレームから複数列を取り出す場合，返り値はベクトルではなく，必ずデータフレームになります。 このため，$ や [[]] は使えません。 ちなみに，以下のような表記法は，返り値としてベクトルが欲しい場合にもデータフレームが欲しい場合にも使えるので，便利です。 しかしながら，tibbleでこの方法は使えないため，残念ながら，こうした表記法は過去のものとなりました。 iris[, &quot;Sepal.Length&quot;] iris[, &quot;Sepal.Length&quot;, drop = FALSE] iris[, c(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;)] 2.2.4.2 データフレームの列 データフレームは，data.frame() で作成します。 データフレーム作成時に注意すべきことは，各列の長さを合わせるということです。 各列の長さが揃わないときは，短い列を繰り返します。 この繰り返しが整数倍でない場合，エラーが返ってきます。 data.frame(year = 1991:2020, value1 = 1:30, value2 = NA, value3 = c(&quot;東&quot;, &quot;西&quot;, &quot;南&quot;), value4 = 1:5) 2.2.5 リスト リストはさまざまな変数を入れることのできる，引き出しだと説明されることがあります。 さまざまな変数をリストに入れることができます。 データフレームのように，各要素の数を揃える必要はありません。 Pythonでいう辞書のようなものです。 リストはさまざまな形を取りますが，実践的には，複数のデータフレームを要素とできる点が便利です。 x &lt;- list() また，関数の返り値がリストとなることがあります。 例えば，データフレームをある列（ファクター）に従って分割したい場合，split() を用います。 x &lt;- split(iris, iris$Species) x[[1]] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5.0 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## 11 5.4 3.7 1.5 0.2 setosa ## 12 4.8 3.4 1.6 0.2 setosa ## 13 4.8 3.0 1.4 0.1 setosa ## 14 4.3 3.0 1.1 0.1 setosa ## 15 5.8 4.0 1.2 0.2 setosa ## 16 5.7 4.4 1.5 0.4 setosa ## 17 5.4 3.9 1.3 0.4 setosa ## 18 5.1 3.5 1.4 0.3 setosa ## 19 5.7 3.8 1.7 0.3 setosa ## 20 5.1 3.8 1.5 0.3 setosa ## 21 5.4 3.4 1.7 0.2 setosa ## 22 5.1 3.7 1.5 0.4 setosa ## 23 4.6 3.6 1.0 0.2 setosa ## 24 5.1 3.3 1.7 0.5 setosa ## 25 4.8 3.4 1.9 0.2 setosa ## 26 5.0 3.0 1.6 0.2 setosa ## 27 5.0 3.4 1.6 0.4 setosa ## 28 5.2 3.5 1.5 0.2 setosa ## 29 5.2 3.4 1.4 0.2 setosa ## 30 4.7 3.2 1.6 0.2 setosa ## 31 4.8 3.1 1.6 0.2 setosa ## 32 5.4 3.4 1.5 0.4 setosa ## 33 5.2 4.1 1.5 0.1 setosa ## 34 5.5 4.2 1.4 0.2 setosa ## 35 4.9 3.1 1.5 0.2 setosa ## 36 5.0 3.2 1.2 0.2 setosa ## 37 5.5 3.5 1.3 0.2 setosa ## 38 4.9 3.6 1.4 0.1 setosa ## 39 4.4 3.0 1.3 0.2 setosa ## 40 5.1 3.4 1.5 0.2 setosa ## 41 5.0 3.5 1.3 0.3 setosa ## 42 4.5 2.3 1.3 0.3 setosa ## 43 4.4 3.2 1.3 0.2 setosa ## 44 5.0 3.5 1.6 0.6 setosa ## 45 5.1 3.8 1.9 0.4 setosa ## 46 4.8 3.0 1.4 0.3 setosa ## 47 5.1 3.8 1.6 0.2 setosa ## 48 4.6 3.2 1.4 0.2 setosa ## 49 5.3 3.7 1.5 0.2 setosa ## 50 5.0 3.3 1.4 0.2 setosa x[[names(x)[2]]] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 51 7.0 3.2 4.7 1.4 versicolor ## 52 6.4 3.2 4.5 1.5 versicolor ## 53 6.9 3.1 4.9 1.5 versicolor ## 54 5.5 2.3 4.0 1.3 versicolor ## 55 6.5 2.8 4.6 1.5 versicolor ## 56 5.7 2.8 4.5 1.3 versicolor ## 57 6.3 3.3 4.7 1.6 versicolor ## 58 4.9 2.4 3.3 1.0 versicolor ## 59 6.6 2.9 4.6 1.3 versicolor ## 60 5.2 2.7 3.9 1.4 versicolor ## 61 5.0 2.0 3.5 1.0 versicolor ## 62 5.9 3.0 4.2 1.5 versicolor ## 63 6.0 2.2 4.0 1.0 versicolor ## 64 6.1 2.9 4.7 1.4 versicolor ## 65 5.6 2.9 3.6 1.3 versicolor ## 66 6.7 3.1 4.4 1.4 versicolor ## 67 5.6 3.0 4.5 1.5 versicolor ## 68 5.8 2.7 4.1 1.0 versicolor ## 69 6.2 2.2 4.5 1.5 versicolor ## 70 5.6 2.5 3.9 1.1 versicolor ## 71 5.9 3.2 4.8 1.8 versicolor ## 72 6.1 2.8 4.0 1.3 versicolor ## 73 6.3 2.5 4.9 1.5 versicolor ## 74 6.1 2.8 4.7 1.2 versicolor ## 75 6.4 2.9 4.3 1.3 versicolor ## 76 6.6 3.0 4.4 1.4 versicolor ## 77 6.8 2.8 4.8 1.4 versicolor ## 78 6.7 3.0 5.0 1.7 versicolor ## 79 6.0 2.9 4.5 1.5 versicolor ## 80 5.7 2.6 3.5 1.0 versicolor ## 81 5.5 2.4 3.8 1.1 versicolor ## 82 5.5 2.4 3.7 1.0 versicolor ## 83 5.8 2.7 3.9 1.2 versicolor ## 84 6.0 2.7 5.1 1.6 versicolor ## 85 5.4 3.0 4.5 1.5 versicolor ## 86 6.0 3.4 4.5 1.6 versicolor ## 87 6.7 3.1 4.7 1.5 versicolor ## 88 6.3 2.3 4.4 1.3 versicolor ## 89 5.6 3.0 4.1 1.3 versicolor ## 90 5.5 2.5 4.0 1.3 versicolor ## 91 5.5 2.6 4.4 1.2 versicolor ## 92 6.1 3.0 4.6 1.4 versicolor ## 93 5.8 2.6 4.0 1.2 versicolor ## 94 5.0 2.3 3.3 1.0 versicolor ## 95 5.6 2.7 4.2 1.3 versicolor ## 96 5.7 3.0 4.2 1.2 versicolor ## 97 5.7 2.9 4.2 1.3 versicolor ## 98 6.2 2.9 4.3 1.3 versicolor ## 99 5.1 2.5 3.0 1.1 versicolor ## 100 5.7 2.8 4.1 1.3 versicolor 2.3 特殊記号 2.3.1 コメント # で始まる行はコメントです。 行の途中に # がある場合は，そこから右，改行までの文字がコメントとみなされます。 Rはコメントを無視します。 コメントは人間が読んで理解できるようなことを書くのに重宝します。 Rはコメントを無視するため，そこには何を書いても問題ありません。 例えば，コードを書き換える場合を想像してみてください。 新しいコードに問題があったときに，古いコードを復活させるかもしれず，残しておきたい，しかし，古いコードは実行したくないというときに，古いコードの先頭にコメントを付けることがあります。 他には，「このコードは一部の人のみ実行してください」や「このコードは実行しなくてもよい」といった意味で使用することもあります。 2.3.2 セミコロン 通常，Rでは1行に複数のコマンドを書きません。 ただし，1行に複数のコマンドを書くこともできます。 何らかの理由により，1行に複数のコマンドを書きたい場合は，次のように ; で繋げます。 x &lt;- 1:100; sum(x) ## [1] 5050 ただし，こうしたからといって処理速度が速くなることはありません。 一方，人間がコードを読むときに，コードが詰まって書かれていると読みづらくなるため，基本的に1行に複数のコマンドは書かないことが多いです。 なお，; を使って書くと，コマンドと返り値の順番に変化がもたらされます。 sum(x) ## [1] 5050 mean(x) ## [1] 50.5 ; のない場合とある場合とで，コマンドと返り値が表示される順番に違いがあることに注目してください。 sum(x); mean(x) ## [1] 5050 ## [1] 50.5 返り値がまとまってほしいときに便利ですが，そうなってほしいことは滅多にありません。 2.3.3 評価と同時に返り値を表示 コマンドを実行して，返り値を得ることを評価と呼びます。 このとき，同時に，その返り値を表示したい場合，コマンド全体を () で括ります。 (x &lt;- 10) ## [1] 10 関数の () とは異なり，全体を () で括ります。 これは次のようなコマンドを実行するのと同じことです。 x &lt;- 10 x ## [1] 10 このように冗長に書くよりも，() を使った方が分かりやすいことがたまにあります。 2.4 入門書 奥村先生による 統計・データ解析 は大変参考になります。 時間をかけてじっくり読むとともに，自分のパソコンで同じようにできるか確かめてください。 また，Posit Cloud にある Posit Primers は時間をかけて読む価値がありそうです。 2.4.1 チートシート Posit Cheat Sheets チートシートの日本語訳がここからダウンロードできます（ページ右側の Downloadボタンをクリック）。 rstudio/cheatsheets 2.5 練習問題 次の変数 x を文字列に変換しなさい。 x &lt;- 1990:2010 次の変数 y を文字列に変換しなさい。 x &lt;- c(&quot;松山市&quot;, &quot;今治市&quot;, &quot;宇和島市&quot;, &quot;八幡浜市&quot;, &quot;新居浜市&quot;, &quot;西条市&quot;, &quot;大洲市&quot;, &quot;伊予市&quot;, &quot;四国中央市&quot;, &quot;西予市&quot;, &quot;東温市&quot;) y &lt;- factor(x, level = x) 次の変数 y を数値に変換しなさい。 x &lt;- c(&quot;2&quot;, &quot;1&quot;, &quot;5&quot;, &quot;4&quot;, &quot;3&quot;) y &lt;- factor(x, level = x) 次のデータフレーム z があるとする。z を使って，2000年以降の value の値の平均を求めなさい。 x &lt;- 1990:2021 y &lt;- seq(5000, 5030, 2) z &lt;- data.frame(year = x, value = y) CSV Files から任意のCSVファイルをダウンロードして，R上の変数 x に読み込みなさい。また，正しく読み込めたかを確かめなさい。 ヒント：CSVファイルを読み込む関数は，read.csv() です。 気象庁の次のWebサイトからCSVファイルをダウンロードして，変数 temp に読み込んだ後，世界全体の年平均気温偏差の最大値と最小値を求めなさい。 世界の年平均気温偏差（℃） 政府統計の総合窓口（e-Stat） から任意のExcelファイルをダウンロードして，R上の変数 excercise に読み込みなさい。また，正しく読み込めたかを確かめなさい。 "],["3-ファイル操作.html", "3 ファイル操作 3.1 ファイルの読み込み 3.2 ディレクトリ構造とファイル管理の基礎 3.3 作業ディレクトリ 3.4 絶対パス 3.5 相対パス 3.6 ファイル出力 3.7 Microsoft 365 3.8 ロケールの変更 3.9 Unicodeエスケープシーケンス 3.10 練習問題", " 3 ファイル操作 今回は，Rにおけるファイル操作について学びます。 とくにRのコンソールがいまどこにいるかを意識していないと，ファイルの読み書きに支障を来します。 コマンドラインに不慣れな人はこのあたりで躓く可能性があります。 3.1 ファイルの読み込み CSV Files から，任意のCSVファイルをダウンロードします。 これをRに読み込んでみましょう。 例えば，addresses.csvをダウンロードした場合，次のコマンドで読み込めます。 read.csv(&quot;addresses.csv&quot;) read.csv(\"\") にある2つの \" の間に，ダウンロードしたファイルの名前を入れます。 拡張子は省略してはいけません。 もし拡張子を非表示にするようにパソコンが設定されている場合は，必ず表示する設定に変更してください。 Windowsの拡張子表示 上のコマンドを実行したとき，ファイルが見つからないというエラーが返ってくる場合，対処方法は2つあります。 ダウンロードしたファイルを作業ディレクトリ（working directory）に移動する。 ダウンロードしたファイルへの絶対パスを指定する。 そもそもの話として，CUI に慣れていない人は，このファイル操作の内容がさっぱり分からないかもしれません。 現代のOSは，GUI であるため，無理もない話です。 そこで，ここで簡単にディレクトリ構造とファイル管理の話をしておきます。 3.2 ディレクトリ構造とファイル管理の基礎 3.2.1 ディレクトリ構造 まず，Windowsのディレクトリ構造について説明します。 macOSもほぼ同じです。 Rを起動した時，Rコンソールは次の場所（フォルダ）にいます。 graph LR C[C:] --- Users Users --- ユーザ名 ユーザ名 --- OneDrive OneDrive --- doc[ドキュメント] style doc fill:#f96,stroke:#333 「いる」というのは，Explorer（Windowsの場合）やFinder（macOSの場合）でその場所を開いていることと同じだと思ってください。 Rは，この場所で作業をします。 ここで，ユーザ名 は今使っているパソコンにログインしているユーザ名のことで，パソコンにログインしているユーザよって異なります。 OneDriveで同期していない人は，次の場所にいるかもしれません。 graph LR C[C:] --- Users Users --- ユーザ名 ユーザ名 --- Documents style Documents fill:#f96,stroke:#333 以下では，OneDriveで同期していない人に限定した説明となっている場合がありますので，適宜読み替えてください。 この図の線の部分を / で置き換えると，CUIで表現できます。 つまり，上の図はCUIでは C:/Users/ユーザ名/Documents または C:/Users/ユーザ名/OneDrive/ドキュメント と表現します（Windowsの場合，/ を ¥ や \\ で表現する場合もあります）。 macOSの場合は，次の場所にいます。 graph LR / --- Users Users --- username[ユーザ名] style username fill:#f96,stroke:#333 macOSは，Windowsの C: のようなドライブレターが存在せず，ルートディレクトリ / から始まります。 以下では，macOSの説明はしませんので，適宜読み替えてください。 一方，Webブラウザを使ってダウンロードしたファイルは，デフォルトでは次の図の Downloads にあるはずです。 graph LR C[C:] --- Users Users --- ユーザ名 ユーザ名 --- OneDrive OneDrive --- doc[ドキュメント] ユーザ名 --- dow[Downloads] style dow fill:#f96,stroke:#333 Downloads はカタカナで ダウンロード という表記になっているかもしれません。 以下の説明では，これらのことが理解できていることを前提としています。 3.2.2 ファイル管理 続いて，ファイル管理について説明します。 これは，Rとは直接は関係ありません。 パソコンの中のファイルの整理方法の説明です。 人によってファイルの整理方法は異なります。 このため，ここに書いてある通りにすべきということではありません。 ただし，以下の説明はここに書いてあることを想定しています。 自分で作ったWordやExcelのファイルだけでなく，インターネットからダウンロードしたファイルは，ドキュメント 以下の関連するフォルダに移動させることを強くおすすめします。 そうしないと，ダウンロード フォルダが訳が分からない状態になってしまいます。 ドキュメント フォルダも同様で，何もルールを決めずにファイルを保存していると，何が何だか分からなくなってしまいます。 そこで，ドキュメント の中にフォルダを作ります。 フォルダの名前は自分で決めてください。 そのフォルダに関連するファイルをフォルダの中に入れていきます。 これらの作業は，Explorer（またはFinder）上で，マウスやトラックパッドを使って行ってください。 そのフォルダの中に，新たなフォルダを作ります。 このフォルダの名前も自分で決めてください。 こうして作成したフォルダは，ツリー状に表現できます。 前節の図の ドキュメント 以下のフォルダ構造の例を示すと，以下のようになります。 flowchart LR ドキュメント --- 大学 ドキュメント --- 就職活動 大学 --- 学部 大学 --- 大学院 学部 --- 1年 学部 --- 2年 学部 --- 3年 学部 --- 4年 4年 --- 授業科目A 4年 --- 授業科目B 授業科目A --- lastweek[2025年1月21日] 授業科目A --- today[2025年1月28日] 授業科目A --- data 授業科目B --- lastweek2[第1回] 授業科目B --- today2[第2回] style lastweek fill:#f96,stroke:#333 style today fill:#f96,stroke:#333 style data fill:#f96,stroke:#333 就職活動 を 大学 の中に入れたい人やまったく別のフォルダ構造にしたい人もいるでしょう。 自分の好きなようにしてください。 ただし，以下の説明では，日付のフォルダに，Rスクリプトや授業に関連するファイルを入れ，data フォルダにダウンロードしたファイルを入れることを想定した説明をします。 自分なりに分かりやすいフォルダを作って，ファイルを整理してください。 3.3 作業ディレクトリ 対処方法の1つ目は，Explorer（またはFinder）でのファイル操作を伴います。 ダウンロードしたCSVファイルがどこにあるか分からない場合は，Webブラウザの設定を確認してください。 ダウンロードしたCSVファイルがどこにあるかは分かったとして，そのファイルをどこに移動すればよいでしょうか。 ファイルの移動先は，以下のコマンドの返り値が指すディレクトリです（ディレクトリはフォルダと同じ意味です。正式にはディレクトリと呼び，GUIを使うときはフォルダと呼ぶことが多いです）。 getwd() ただし，このコマンドの返り値のディレクトリで本当によいかは，その人によります。 といっても分からないと思いますので，作業ディレクトリは次の方法で変更しましょう。 Windowsの場合，メニューの[ファイル]→[ディレクトリの変更…]から作業ディレクトリを変更します。 macOSの場合，メニューの[その他]→[作業ディレクトリの変更…]から作業ディレクトリを変更します。 ここで，先ほどCSVファイルがダウンロードされたディレクトリを指定すればよいです。 しかしながら，ここでは，作業ディレクトリをどこかに決めることをおすすめします。 作業ディレクトリはRを終了すると初期化されます（デフォルト値に戻る）ので，Rを起動するたびに毎回，この操作を行います。 毎回同じ場所でもよいですし，通常は目的（プロジェクト，論文，授業など）ごとに変更すべきでしょう。 どこを作業ディレクトリにするかは自分で決めてください。 Rに関連するファイルしか存在しないディレクトリを作成しておくと，作業がしやすいです。 例えば，ドキュメント ディレクトリの中に授業のディレクトリを作成し，その中に授業の回数ごとにディレクトリを作成する方法が考えられます。 そこでは，Rのプログラムに関するファイルを作成しておくとよいでしょう。 3.3.1 Rのコードの保存 Rのプログラムが書かれたもの（関数やコマンドのかたまり）を，コードと言ったり，スクリプトと言ったりします。 通常，コードはテキストエディタを使って書きます。 文字を書くのにMicrosoft Wordしか使ったことがない人が多いので，テキストエディタと言われてもよくわからないと思います。 テキストエディタは，Windowsの場合は 秀丸エディタ が有名で，おすすめです。 秀丸エディタは有料ですが，学生は支払いが免除されるはずでし，支払わなくても警告が出たときにその警告を閉じれば作業できます（Windowsのメモ帳は改行コードに関連するバグを経験したことがあるため，あまりおすすめしません）。 他に，サクラエディタ や Notepad++ などがあります。 一方，macOSの場合はOS標準の テキストエディット.app がおすすめです。 また，OSに関係なく，Visual Studio Code を使うのもよいかもしれません。 Rのスクリプトに書かれたコードを必要な部分だけコピーして，Rコンソールにペーストしてから，実行してください。 ただし，Visual Studio Code は多機能であるため，Rを直接実行できるのですが，Rに慣れないうちはRと Visual Studio Code をコピー&amp;ペーストで行き来しながら，コードはRコンソールから実行するようにしてください。 Rのコードが書かれたファイルは，拡張子を R として，文字コードがUTF-8のテキストファイルとして保存します。 拡張子が R のファイルは，ダブルクリックして開いても構いませんが，テキストエディタで開くことをおすすめします。 OSで関連付けてもいいですし，毎回ファイルを右クリックして開くアプリケーションを選んだとしても，それほど苦ではないと思います。 （この作業が苦痛な人にはRは向かないのではないでしょうか。） 3.3.2 作業ディレクトリの変更 上記のようなマウス操作をしない方法もあり，操作をRコンソール内で完結させることができます。 次のコマンドを知っておくと便利です。 setwd(&quot;&quot;) このコマンドの \"\" の中には，自分のパソコンのディレクトリ構造の中のある特定の場所を指定します。 この場所は，Windowsなら C: から始まり，macOSなら / から始まる階層構造における位置のことで，パスと呼びます。 このパスはファイル名ではなく，ディレクトリ名で終わることに注意してください。 ここで行っているのは，作業ディレクトリの変更です。 実際の使用時には，例えば，次のように書きます。 setwd(&quot;C:/Users/ユーザ名/OneDrive/ドキュメント&quot;) OneDriveで同期していない人は次のように書きます。 setwd(&quot;C:/Users/ユーザ名/Documents&quot;) これは，次のコマンドと同じです。 setwd(&quot;~&quot;) \"~\" はホームディレクトリを意味します。 3.4 絶対パス エラーへの対処方法の2つ目は，Rコンソールの場所は移動せずに，コマンド実行時に絶対パスを指定する方法です。 これは，次のコマンドによって実現します。 read.csv(&quot;C:/Users/ユーザ名/Downloads/addresses.csv&quot;) # Windowsの例 # read.csv(&quot;/Users/ユーザ名/Downloads/addresses.csv&quot;) # macOSの例 これは，次のファイルを読んでいることを意味します。 graph LR C[C:] --- Users Users --- ユーザ名 ユーザ名 --- Downloads Downloads --- file[addresses.csv] style file fill:#f96,stroke-width:0px Windowsの場合（おそらくWindows 11以降），ダウンロードしたファイルを右クリックして，「パスのコピー」をクリックすると，クリップボードにそのファイルの絶対パスがコピーされます。 コピーした後，read.csv(\"\") にある2つの \" の間にペーストしてください。 macOSの場合，Terminal.appを起動して，そのウィンドウにダウンロードしたファイルをドラッグ＆ドロップすれば，絶対パスが表示されます。 絶対パス正しければ，上のコマンドでCSVファイルの中身が表示されるはずです。 実際には，Rを起動した直後に作業ディレクトリを一度変更し，その後は相対パスを変更しながら，ファイルの読み書きをすることになるはずです。 なお，こうした煩雑さを緩和する目的で，here パッケージがありますので，知りたい人は調べてください。 3.5 相対パス 相対パスは現在の作業ディレクトリを起点として，相対的にどこのファイルを読み書きするかを指定する考え方です。 Rによるディレクトリの作成と合わせて考えると非常に便利です。 例えば，作業ディレクトリの下に新たなディレクトリを作成し，そこにファイルをダウンロードした後に，そのファイルを読むには次のようにします。 次のコードを実行する前に，Explorer（またはFinder）で作業ディレクトリを表示させておき，次のコードを実行することで起こる変化を注視してください。 dir.create(&quot;./data&quot;) download.file(&quot;https://people.sc.fsu.edu/~jburkardt/data/csv/addresses.csv&quot;, &quot;./data/addresses.csv&quot;) df &lt;- read.csv(&quot;./data/addresses.csv&quot;) df ## John Doe X120.jefferson.st. Riverside ## 1 Jack McGinnis 220 hobo Av. Phila ## 2 John &quot;Da Man&quot; Repici 120 Jefferson St. Riverside ## 3 Stephen Tyler 7452 Terrace &quot;At the Plaza&quot; road SomeTown ## 4 Blankman SomeTown ## 5 Joan &quot;the bone&quot;, Anne Jet 9th, at Terrace plc Desert City ## NJ X08075 ## 1 PA 9119 ## 2 NJ 8075 ## 3 SD 91234 ## 4 SD 298 ## 5 CO 123 パスの先頭にある . は自分がいるディレクトリを意味する記号です。 このことから，./ は作業ディレクトリを指します。 ./ はあってもなくても同じです。 ただし，\"./data\" と \"data\" は同じ意味ですが，\"/data\" は意味が異なりますので注意してください。 もし dir.create(\"/data\") とした場合は，作業ディレクトリではなく，ルートディレクトリに新たなディレクトリが作成されます（こうした操作はOSにとって脅威となりますので，絶対にやらないでください）。 上述のコードは，dir.create() でディレクトリを作成し，download.file() でファイルをダウンロードした後，read.csv() でダウンロードしたファイルを読み込みます。 このことを図で表現すると，次のようになります。 graph LR C[C:] --- Users Users --- ユーザ名 ユーザ名 --- OneDrive OneDrive --- doc[ドキュメント] doc --- data data --- file[addresses.csv] style data fill:#f96,stroke:#333 style file fill:#f96,stroke-width:0px Rの作業ディレクトリは ドキュメント ですので，ここから相対的にひとつ下に data というディレクトリを作成し，その中にダウンロードしたファイルを保存し，その保存したファイルを読み込んでいます。 実際には，パソコンの C: の中にファイルはありますが，Rで読み込む際に C: から始める必要はありません。 このことを図で表現すると，次のようになります。 graph LR dot[&quot;~&quot;] --- data data --- file[addresses.csv] style data fill:#f96,stroke:#333 style file fill:#f96,stroke-width:0px ~ はホームディレクトリを意味する記号であり，OneDriveで同期している人は \"C:/Users/ユーザ名/OneDrive/ドキュメント\"，同期していない人は \"C:/Users/ユーザ名/Documents\" を指します。 先ほどの結果を見て，1行目の左側に数字がついておらず，2行目が1，6行目が6となっています。 これは，Rが1行目をヘッダーとして読み込んでいるという意味です。 これで正しい場合もありますが，この例は1行目もレコードなので，次のようにしなければなりません。 df &lt;- read.csv(&quot;data/addresses.csv&quot;, header = FALSE) df ## V1 V2 V3 V4 ## 1 John Doe 120 jefferson st. Riverside ## 2 Jack McGinnis 220 hobo Av. Phila ## 3 John &quot;Da Man&quot; Repici 120 Jefferson St. Riverside ## 4 Stephen Tyler 7452 Terrace &quot;At the Plaza&quot; road SomeTown ## 5 Blankman SomeTown ## 6 Joan &quot;the bone&quot;, Anne Jet 9th, at Terrace plc Desert City ## V5 V6 ## 1 NJ 8075 ## 2 PA 9119 ## 3 NJ 8075 ## 4 SD 91234 ## 5 SD 298 ## 6 CO 123 ヘッダーをどうすべきかはファイルによって異なります。 例えば，次の例では，ヘッダーを TRUE にすべきです（省略時のヘッダーは TRUE であるため，省略してもよい）。 download.file(&quot;https://people.sc.fsu.edu/~jburkardt/data/csv/airtravel.csv&quot;, &quot;data/airtravel.csv&quot;) df &lt;- read.csv(&quot;data/airtravel.csv&quot;, header = TRUE) df ## Month X1958 X1959 X1960 ## 1 JAN 340 360 417 ## 2 FEB 318 342 391 ## 3 MAR 362 406 419 ## 4 APR 348 396 461 ## 5 MAY 363 420 472 ## 6 JUN 435 472 535 ## 7 JUL 491 548 622 ## 8 AUG 505 559 606 ## 9 SEP 404 463 508 ## 10 OCT 359 407 461 ## 11 NOV 310 362 390 ## 12 DEC 337 405 432 ヘッダーが数字で始まる場合，先頭に X が付き，文字列に変換されます。 ここで，次のようにあえて間違った読み方をして，結果がどうなるかを確認してください。 df &lt;- read.csv(&quot;data/airtravel.csv&quot;, header = FALSE) df ## V1 V2 V3 V4 ## 1 Month 1958 1959 1960 ## 2 JAN 340 360 417 ## 3 FEB 318 342 391 ## 4 MAR 362 406 419 ## 5 APR 348 396 461 ## 6 MAY 363 420 472 ## 7 JUN 435 472 535 ## 8 JUL 491 548 622 ## 9 AUG 505 559 606 ## 10 SEP 404 463 508 ## 11 OCT 359 407 461 ## 12 NOV 310 362 390 ## 13 DEC 337 405 432 正しく読み込めたかどうかは，Rの表示と元のCSVファイル（テキストエディタやMicrosoft Excelを使って表示）を比較して確かめてください。 以上の例のように，一度ダウンロードしたファイルは自分のパソコンに残っているため，read.csv() を使って何度も読み直すときに download.file() は必要ありません。 これは，Explorer（またはFinder）における通常のファイル操作と同じです。 ここでよくある例を挙げておきます。 例えば，次のように別のCSVファイルを読み込んでください。 download.file(&quot;https://people.sc.fsu.edu/~jburkardt/data/csv/biostats.csv&quot;, &quot;data/biostats.csv&quot;) df &lt;- read.csv(&quot;data/biostats.csv&quot;, header = TRUE) df ## Name Sex Age Height..in. Weight..lbs. ## 1 Alex M 41 74 170 ## 2 Bert M 42 68 166 ## 3 Carl M 32 70 155 ## 4 Dave M 39 72 167 ## 5 Elly F 30 66 124 ## 6 Fran F 33 66 115 ## 7 Gwen F 26 64 121 ## 8 Hank M 30 71 158 ## 9 Ivan M 53 72 175 ## 10 Jake M 32 69 143 ## 11 Kate F 47 69 139 ## 12 Luke M 34 72 163 ## 13 Myra F 23 62 98 ## 14 Neil M 36 75 160 ## 15 Omar M 38 70 145 ## 16 Page F 31 67 135 ## 17 Quin M 29 71 176 ## 18 Ruth F 28 65 131 biostats.csv を読み込むと，元のファイルと比較してヘッダーがおかしくなっています。 () とスペースが . に置き換わっていることが分かります。 CSVファイルのヘッダーを変更せずにそのまま読むには，次のようにします。 df &lt;- read.csv(&quot;data/biostats.csv&quot;, check.names = FALSE) df ## Name Sex Age Height (in) Weight (lbs) ## 1 Alex M 41 74 170 ## 2 Bert M 42 68 166 ## 3 Carl M 32 70 155 ## 4 Dave M 39 72 167 ## 5 Elly F 30 66 124 ## 6 Fran F 33 66 115 ## 7 Gwen F 26 64 121 ## 8 Hank M 30 71 158 ## 9 Ivan M 53 72 175 ## 10 Jake M 32 69 143 ## 11 Kate F 47 69 139 ## 12 Luke M 34 72 163 ## 13 Myra F 23 62 98 ## 14 Neil M 36 75 160 ## 15 Omar M 38 70 145 ## 16 Page F 31 67 135 ## 17 Quin M 29 71 176 ## 18 Ruth F 28 65 131 ここで，Explorer（またはFinder）から先ほど作成した data フォルダを削除しておいてください。 なお，相対パスの先頭に .. または ../ を書くこともできます。 これらの記号は，作業ディレクトリのひとつ上の階層のディレクトリを意味します。 次のコードは，Rの作業ディレクトリの1つ上の階層に，dataという名前のディレクトリを作成するもので，ファイルの出力先を指定する際に頻繁に使います。 outdir &lt;- &quot;../data&quot; if (!file.exists(outdir)) { dir.create(outdir) } これは次のようにやっても同じです。 outdir &lt;- &quot;../data&quot; dir.create(outdir, showWarnings = FALSE) もし作業ディレクトリがホームディレクトリにある場合（Rを起動してから作業ディレクトリを変更していない場合）は，このコードは実行しないでください。 もし実行してしまった場合は，Explorer（またはFinder）で作業ディレクトリと同じ階層にある data フォルダの中を確認し，何もファイルがなければ data フォルダを削除してください。 ファイルがあれば，他のアプリケーションで使用している可能性があるため，data フォルダを削除せず，残しておいてください。 上記コードの2行目と4行目は，すでにそのディレクトリがある場合は，何もしないことを意味します。 このコマンドを理解するには，条件分岐と ! の意味を正しく理解できなければなりません。 ここで，outdirという名前の変数を作っているのは，それ以降に同じ記述が2回登場するためです。 後になって，もしディレクトリを変更したくなった場合，2箇所修正するよりも1箇所修正する方が間違いが少なくてすみます。 .. の知識を踏まえると，Webブラウザを使ってダウンロードしたファイルを，ホームディレクトリから読み込むことができます。 作業ディレクトリを確実にホームディレクトリにするために，次のコマンドを実行してください。 setwd(&quot;~&quot;) Webブラウザを使って，CSV Files から，任意のCSVファイルをダウンロードしてください。 このCSVファイルをRに読み込むには，どうすればよいでしょうか。 図で考えると次の相対パスを考えることに他なりません。 graph LR C[C:] --- Users Users --- ユーザ名 ユーザ名 --- OneDrive OneDrive --- doc[ドキュメント] ユーザ名 --- Downloads Downloads --- file[cities.csv] doc -- .. --&gt; OneDrive OneDrive -- .. --&gt; ユーザ名 ユーザ名 --&gt; Downloads Downloads --&gt; file style file fill:#f96,stroke-width:0px linkStyle 6 stroke:red linkStyle 7 stroke:red linkStyle 8 stroke:red linkStyle 9 stroke:red これをRのコマンドにすると次のようになります。 df &lt;- read.csv(&quot;../../Downloads/cities.csv&quot;) df なお，上述の . の説明を踏まえると，これは次のように書くこともできます。 df &lt;- read.csv(&quot;./../../Downloads/cities.csv&quot;) df ただし，こういう場合に， ./ を書くのは冗長な印象を受けます。 ./ はあってもなくても結果は同じですが，上の階層に行く場合は .. から始めるべきでしょう。 OneDriveで同期していない人は，ディレクトリをひとつ上がるパスが1つ減ります。 graph LR C[C:] --- Users Users --- ユーザ名 ユーザ名 --- Documents ユーザ名 --- Downloads Downloads --- file[cities.csv] Documents == .. ==&gt; ユーザ名 ユーザ名 ==&gt; Downloads Downloads ==&gt; file style file fill:#f96,stroke-width:0px linkStyle 5 stroke:red linkStyle 6 stroke:red linkStyle 7 stroke:red df &lt;- read.csv(&quot;../Downloads/cities.csv&quot;) df ## LatD LatM LatS NS LonD LonM LonS EW City State ## 1 41 5 59 N 80 39 0 W Youngstown OH ## 2 42 52 48 N 97 23 23 W Yankton SD ## 3 46 35 59 N 120 30 36 W Yakima WA ## 4 42 16 12 N 71 48 0 W Worcester MA ## 5 43 37 48 N 89 46 11 W Wisconsin Dells WI ## 6 36 5 59 N 80 15 0 W Winston-Salem NC ## 7 49 52 48 N 97 9 0 W Winnipeg MB ## 8 39 11 23 N 78 9 36 W Winchester VA ## 9 34 14 24 N 77 55 11 W Wilmington NC ## 10 39 45 0 N 75 33 0 W Wilmington DE ## 11 48 9 0 N 103 37 12 W Williston ND ## 12 41 15 0 N 77 0 0 W Williamsport PA ## 13 37 40 48 N 82 16 47 W Williamson WV ## 14 33 54 0 N 98 29 23 W Wichita Falls TX ## 15 37 41 23 N 97 20 23 W Wichita KS ## 16 40 4 11 N 80 43 12 W Wheeling WV ## 17 26 43 11 N 80 3 0 W West Palm Beach FL ## 18 47 25 11 N 120 19 11 W Wenatchee WA ## 19 41 25 11 N 122 23 23 W Weed CA ## 20 31 13 11 N 82 20 59 W Waycross GA ## 21 44 57 35 N 89 38 23 W Wausau WI ## 22 42 21 36 N 87 49 48 W Waukegan IL ## 23 44 54 0 N 97 6 36 W Watertown SD ## 24 43 58 47 N 75 55 11 W Watertown NY ## 25 42 30 0 N 92 20 23 W Waterloo IA ## 26 41 32 59 N 73 3 0 W Waterbury CT ## 27 38 53 23 N 77 1 47 W Washington DC ## 28 41 50 59 N 79 8 23 W Warren PA ## 29 46 4 11 N 118 19 48 W Walla Walla WA ## 30 31 32 59 N 97 8 23 W Waco TX ## 31 38 40 48 N 87 31 47 W Vincennes IN ## 32 28 48 35 N 97 0 36 W Victoria TX ## 33 32 20 59 N 90 52 47 W Vicksburg MS ## 34 49 16 12 N 123 7 12 W Vancouver BC ## 35 46 55 11 N 98 0 36 W Valley City ND ## 36 30 49 47 N 83 16 47 W Valdosta GA ## 37 43 6 36 N 75 13 48 W Utica NY ## 38 39 54 0 N 79 43 48 W Uniontown PA ## 39 32 20 59 N 95 18 0 W Tyler TX ## 40 42 33 36 N 114 28 12 W Twin Falls ID ## 41 33 12 35 N 87 34 11 W Tuscaloosa AL ## 42 34 15 35 N 88 42 35 W Tupelo MS ## 43 36 9 35 N 95 54 36 W Tulsa OK ## 44 32 13 12 N 110 58 12 W Tucson AZ ## 45 37 10 11 N 104 30 36 W Trinidad CO ## 46 40 13 47 N 74 46 11 W Trenton NJ ## 47 44 45 35 N 85 37 47 W Traverse City MI ## 48 43 39 0 N 79 22 47 W Toronto ON ## 49 39 2 59 N 95 40 11 W Topeka KS ## 50 41 39 0 N 83 32 24 W Toledo OH ## 51 33 25 48 N 94 3 0 W Texarkana TX ## 52 39 28 12 N 87 24 36 W Terre Haute IN ## 53 27 57 0 N 82 26 59 W Tampa FL ## 54 30 27 0 N 84 16 47 W Tallahassee FL ## 55 47 14 24 N 122 25 48 W Tacoma WA ## 56 43 2 59 N 76 9 0 W Syracuse NY ## 57 32 35 59 N 82 20 23 W Swainsboro GA ## 58 33 55 11 N 80 20 59 W Sumter SC ## 59 40 59 24 N 75 11 24 W Stroudsburg PA ## 60 37 57 35 N 121 17 24 W Stockton CA ## 61 44 31 12 N 89 34 11 W Stevens Point WI ## 62 40 21 36 N 80 37 12 W Steubenville OH ## 63 40 37 11 N 103 13 12 W Sterling CO ## 64 38 9 0 N 79 4 11 W Staunton VA ## 65 39 55 11 N 83 48 35 W Springfield OH ## 66 37 13 12 N 93 17 24 W Springfield MO ## 67 42 5 59 N 72 35 23 W Springfield MA ## 68 39 47 59 N 89 39 0 W Springfield IL ## 69 47 40 11 N 117 24 36 W Spokane WA ## 70 41 40 48 N 86 15 0 W South Bend IN ## 71 43 32 24 N 96 43 48 W Sioux Falls SD ## 72 42 29 24 N 96 23 23 W Sioux City IA ## 73 32 30 35 N 93 45 0 W Shreveport LA ## 74 33 38 23 N 96 36 36 W Sherman TX ## 75 44 47 59 N 106 57 35 W Sheridan WY ## 76 35 13 47 N 96 40 48 W Seminole OK ## 77 32 25 11 N 87 1 11 W Selma AL ## 78 38 42 35 N 93 13 48 W Sedalia MO ## 79 47 35 59 N 122 19 48 W Seattle WA ## 80 41 24 35 N 75 40 11 W Scranton PA ## 81 41 52 11 N 103 39 36 W Scottsbluff NB ## 82 42 49 11 N 73 56 59 W Schenectady NY ## 83 32 4 48 N 81 5 23 W Savannah GA ## 84 46 29 24 N 84 20 59 W Sault Sainte Marie MI ## 85 27 20 24 N 82 31 47 W Sarasota FL ## 86 38 26 23 N 122 43 12 W Santa Rosa CA ## 87 35 40 48 N 105 56 59 W Santa Fe NM ## 88 34 25 11 N 119 41 59 W Santa Barbara CA ## 89 33 45 35 N 117 52 12 W Santa Ana CA ## 90 37 20 24 N 121 52 47 W San Jose CA ## 91 37 46 47 N 122 25 11 W San Francisco CA ## 92 41 27 0 N 82 42 35 W Sandusky OH ## 93 32 42 35 N 117 9 0 W San Diego CA ## 94 34 6 36 N 117 18 35 W San Bernardino CA ## 95 29 25 12 N 98 30 0 W San Antonio TX ## 96 31 27 35 N 100 26 24 W San Angelo TX ## 97 40 45 35 N 111 52 47 W Salt Lake City UT ## 98 38 22 11 N 75 35 59 W Salisbury MD ## 99 36 40 11 N 121 39 0 W Salinas CA ## 100 38 50 24 N 97 36 36 W Salina KS ## [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 28 rows ] ここで，.. という記号は，そのディレクトリがどのような名前であるかは気にすることなく，ひとつ上の階層のディレクトリを指定できることができるという非常に便利な性質を持っていることに注目してください。 3.5.1 Tips パスの入力中に Tabキー を押すと，選択肢としてあり得る候補が現れ，Enterキー （または Returnキー）で入力補完されます。 Windowsの場合，保管できる候補が複数ある場合は，Tabキー を2回連続で押すと，選択肢としてあり得るディレクトリがサジェストされます。 このことを知っていると，パス入力の手間が省けます。 また，パスを入力し間違っていると Tabキー を押しても反応がないため，入力ミスに気づきやすいです。 3.6 ファイル出力 Rコンソールがいる場所（ディレクトリ）がどこであるかを意識する必要があるのは，ファイル入出力のときです。 これまで，ファイル入力のみを行ってきました。 ここで，ファイル出力を経験することにより，作業ディレクトリの重要性を理解しましょう。 Rの返り値をコンソールではなく，ファイルに出力する関数が sink() です。 例えば，次のコードを実行するとどうなるでしょうか。 sink(&quot;test.txt&quot;) iris sink() Rコンソールには何も表示されません。 その代わりに，作業ディレクトリに test.txt というテキストファイルができているはずです。 Explorer（またはFinder）で確認してください。 この例のように，sink() の引数に保存したいファイル名を書きます。 ここでは，ファイル名だけで，ディレクトリを書いていないので，作業ディレクトリに保存されました。 また，ファイル出力が終わったら，必ず引数なしで sink() としてファイルを閉じてください。 相対パスでディレクトリを書くと，その場所に保存されます。 例えば次のようにすると，どうなるか予想し，予想どおりになっていることを確かめてください。 sink(&quot;../../Downloads/test.txt&quot;) # OneDriveで同期している場合 # sink(&quot;../Downloads/test.txt&quot;) # OneDriveで同期していない場合 cars sink() OneDriveで同期していない人は，2行目の # の右側以降をRコンソールにコピーして，コードを実行してください。 3.7 Microsoft 365 Microsoft365R パッケージは，Microsoft 365 の R インターフェースです。 大学のメールアドレスで OneDrive を使用している場合は，次のコードを実行します。 library(Microsoft365R) odb &lt;- get_business_onedrive() プライベートなメールアドレスで OneDrive を使用している場合は，次のコードを実行します。 od &lt;- get_personal_onedrive() すると，Webブラウザが起動し，Microsoft 365 へのログインが促された後，「コードの入力」ウィンドウで，「モバイル デバイスの Microsoft Authenticator アプリに表示されているコードを入力してください​」と表示されます。 指示に従うと，R から Microsoft 365 を操作できるようになります。 例えば，次のようなことができます。 # list files and folders odb$list_items() odb$list_items(&quot;ドキュメント&quot;) # upload and download files odb$upload_file(&quot;somedata.xlsx&quot;) odb$download_file(&quot;ドキュメント/myfile.docx&quot;) # create a folder odb$create_folder(&quot;ドキュメント/newfolder&quot;) # open a document for editing in Word Online odb$open_item(&quot;ドキュメント/myfile.docx&quot;) # working with data frames and R objects library(readr) odb$save_dataframe(iris, &quot;ドキュメント/iris.csv&quot;) ただし，便利かどうかは不明です。 3.8 ロケールの変更 Rコンソールがどの文字コードを使っているかを知りたいことがあるかもしれません（通常，これは知る必要はありません）。 次のコマンドでロケールを知ることができます。 system(&quot;locale&quot;) 一般的に，このような結果が得られるはずです。 LANG=&quot;ja_JP.UTF-8&quot; LC_COLLATE=&quot;ja_JP.UTF-8&quot; LC_CTYPE=&quot;ja_JP.UTF-8&quot; LC_MESSAGES=&quot;ja_JP.UTF-8&quot; LC_MONETARY=&quot;ja_JP.UTF-8&quot; LC_NUMERIC=&quot;ja_JP.UTF-8&quot; LC_TIME=&quot;ja_JP.UTF-8&quot; LC_ALL= または，次のような結果が得られるかもしれません。 LANG=&quot;en_US.UTF-8&quot; LC_COLLATE=&quot;en_US.UTF-8&quot; LC_CTYPE=&quot;en_US.UTF-8&quot; LC_MESSAGES=&quot;en_US.UTF-8&quot; LC_MONETARY=&quot;en_US.UTF-8&quot; LC_NUMERIC=&quot;en_US.UTF-8&quot; LC_TIME=&quot;en_US.UTF-8&quot; LC_ALL= これらの場合は，日本語は正しく表示されるはずです。 環境によっては，次のような結果が得られるかもしれません。 LANG=&quot;en_JP.UTF-8&quot; LC_COLLATE=&quot;C&quot; LC_CTYPE=&quot;C&quot; LC_MESSAGES=&quot;C&quot; LC_MONETARY=&quot;C&quot; LC_NUMERIC=&quot;C&quot; LC_TIME=&quot;C&quot; LC_ALL= この場合，日本語の表示はおかしいですが，任意の日本語を含むコードは正しく処理されるはずです。 日本語が表示される環境に設定したければ，次のようにします。 system(&quot;defaults write org.R-project.R force.LANG ja_JP.UTF-8&quot;) おそらくこれはmacOSだけに対応しているはずです。 Windowsでのロケールの変更方法は知りません。 3.9 Unicodeエスケープシーケンス 日本語を扱いたいにもかかわらず，もし何らかの制約があり，RコードにはASCII文字しか使えない場合があるかもしれません。 そのとき，次のコマンドを使うことで対応します。 library(stringi) stri_escape_unicode(&quot;日本語&quot;) ## [1] &quot;\\\\u65e5\\\\u672c\\\\u8a9e&quot; あるいは，次のようにしてもよいでしょう。 paste0(&quot;\\\\u&quot;, sprintf(&quot;%04x&quot;, utf8ToInt(&quot;日本語&quot;)), collapse = &quot;&quot;) ## [1] &quot;\\\\u65e5\\\\u672c\\\\u8a9e&quot; \\ が2つずつ連続していますが，Rコードで用いるときは \\ は1つで大丈夫です。 3.10 練習問題 未作成 "],["4-比較演算.html", "4 比較演算 4.1 比較演算 4.2 条件分岐 4.3 繰り返し処理 4.4 データ・クリーニング 4.5 関数の作成 4.6 練習問題", " 4 比較演算 今回は比較演算子の使い方を学びます。 比較演算ができるようになれば，条件分岐と繰り返し処理の理解が進みます。 4.1 比較演算 比較演算とは比較演算子を使った判定のことです。 数値の比較はみなさんが日常的に行ってことですので，分かりやすいはずです。 4.1.1 数値 比較演算子の1つに == があります。 year &lt;- 2000 year == 2000 ## [1] TRUE year == 2001 ## [1] FALSE = は必ず2つ連続で使用します。 = を1つしか使わない場合，関数の引数以外では，&lt;- と同じ意味になってしまいますので，注意が必要です。 上のコマンドは，== の左側と右側が等しいかどうかを判定しています。 比較演算の返り値は論理値です。 また，ベクトルを比較演算子の左側に置いた場合，返り値は左側のベクトルと同じ長さのベクトルになります。 year &lt;- 1990:2010 year == 2000 ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE ## [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE length(year) ## [1] 21 which(year == 2000) ## [1] 11 ベクトルの各要素を表示し，返り値との対応関係が正しいことを確かめてください。 year ## [1] 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 ## [16] 2005 2006 2007 2008 2009 2010 Rコンソールに表示されるベクトルが何行目で改行されるかは，そのベクトルによって異なります。 このため，2行目がベクトルの何番目であるかはそのベクトルに依存します。 左の [] 内に表示される数字がベクトルの何番目の要素であるかを示しています。 == のほかに，次のような比較演算子があります。 これらの比較演算は直感的に理解できるはずです。 year &gt; 2000 ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE ## [13] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ここで，ベクトルの各要素1つずつに対して比較していることを理解してください。 現在，year は次のようになっています。 year ## [1] 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 ## [16] 2005 2006 2007 2008 2009 2010 このベクトルの1つ目の要素と 2000 を比較した結果が year &gt; 2000 の返り値のベクトルの1つ目の要素 FALSE に対応しています。 そして，このベクトルの12個目の要素と 2000 を比較した結果が year &gt; 2000 の返り値のベクトルは12個目の要素 TRUE に対応しています。 以下の比較演算子についても同様です。 year &lt; 2000 ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE FALSE FALSE ## [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE year &gt;= 2000 ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE ## [13] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE year &lt;= 2000 ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE FALSE ## [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE &gt;= は =&gt; とするとエラーが返ってきます。 &lt;= も同様に &lt;= としてはいけません。 ここでもベクトルの返り値がベクトルであることに注意してください。 比較演算子の先頭に ! をつけることができます。 この ! は否定を意味します。 == の場合は，!= とすると == が真ではないものという意味になります。 year != 2000 ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE FALSE TRUE ## [13] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE != の返り値は， == のちょうど反対であることが分かるはずです。 なお，!&gt; や !&lt; は使えません。 &gt; の否定は &lt;= で表現できるため，これらのコマンドが使えなくてもとくに困りません。 比較演算は，ベクトルや行列の一部を取り出すときによく使います。 例えば，次のようにします。 year[year &gt;= 2000] ## [1] 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 一見冗長な書き方のように見えますが，これで問題ありません。 [] の内側は論理値のベクトルであり，[] の外側（ year ）のベクトルと長さが同じ（または，外側が内側の整数倍）でなければなりません。 この場合は [] の外側と内側で同じ変数 year を使っているので，必ずベクトルの長さが同じになります。 [] の外側のベクトルに対して，内側のベクトルの長さが短い場合は，内側のベクトルを繰り返します。 例えば，次のようにすると，c(TRUE, FALSE, FALSE) は7回繰り返され，返り値は7つの要素を持つベクトルになります。 year[c(TRUE, FALSE, FALSE)] ## [1] 1990 1993 1996 1999 2002 2005 2008 length(year) が 21 であり，これを length(c(TRUE, FALSE, FALSE)) の 3 で割ると，7 になります。 [] の外側が内側の整数倍の長さのベクトルという性質を使うことはほとんどないため，このことを知らなくても困ることはほとんどないでしょう。 むしろ，ベクトルの長さが違っていてもエラーにならない可能性があることから，思わぬバグに気づかないかもしれません。 比較演算は，実際によく使います。 例えば，次のような使い方をします。 year &lt;- 1990:2010 y &lt;- seq(5000, 5040, 2) z &lt;- data.frame(year = year, value = y) mean(z[z$year &gt; 2000, ]$value) ## [1] 5031 最後の部分は次のようにしても同じです。 mean(z$value[z$year &gt; 2000]) ## [1] 5031 このことがいまいちピンとこない人は，次のように分解して考えてみてください。 (zd1 &lt;- z$year &gt; 2000) ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE ## [13] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE (zd2 &lt;- z[zd1, ]) ## year value ## 12 2001 5022 ## 13 2002 5024 ## 14 2003 5026 ## 15 2004 5028 ## 16 2005 5030 ## 17 2006 5032 ## 18 2007 5034 ## 19 2008 5036 ## 20 2009 5038 ## 21 2010 5040 (zd3 &lt;- zd2$value) ## [1] 5022 5024 5026 5028 5030 5032 5034 5036 5038 5040 mean(zd3) ## [1] 5031 これまでの説明で，返り値が論理値であることが混乱を招く原因になっているかもしれません。 しかし，これは R の便利な特徴のひとつですので，必ず理解してください。 もしかしたら，判定が真となる要素がベクトルの何番目の要素であるかを返す関数 which() の方が理解が容易でしょうか。 which(year &gt;= 2000) ## [1] 11 12 13 14 15 16 17 18 19 20 21 このため，次のようにすることができます。 (zd &lt;- which(z$year &gt;= 2000)) ## [1] 11 12 13 14 15 16 17 18 19 20 21 z$value[zd] ## [1] 5020 5022 5024 5026 5028 5030 5032 5034 5036 5038 5040 ただし，これは次のようにすることと同じです。 z$value[z$year &gt;= 2000] ## [1] 5020 5022 5024 5026 5028 5030 5032 5034 5036 5038 5040 返り値と関数の引数は異なります。 このように，ベクトルを取り出すとき，何番目であるかを指定する方法と，論理値で指定する方法の2つがあることを知っておいてください。 今後自分でコードを書くとき，このことが混乱の原因になるかもしれません。 もし混乱した場合は，そのとき扱っている変数が数値なのか論理値なのかを考えると，頭の中が整理されるはずです。 4.1.1.1 NA ベクトルに NA が含まれるとき，NA のある場所では評価（比較演算）しません。 x &lt;- sample(10, 10) x[sample(10, 1)] &lt;- NA x &gt; 5 ## [1] TRUE FALSE FALSE TRUE FALSE NA TRUE TRUE FALSE TRUE x[x &gt; 5] ## [1] 7 10 NA 9 6 8 NA を取り除きたい場合は，条件をもう1つ追加しなければなりません。 NA かどうかは次の関数で判定します。 is.na(x) ## [1] FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE 実践では，NA 以外を取り出したい場合は，否定の ! が使えます。 !is.na(x) ## [1] TRUE TRUE TRUE TRUE TRUE FALSE TRUE TRUE TRUE TRUE NA を取り除くと，ベクトルの要素の数が減ることに注意してください。 length(x[!is.na(x)]) ## [1] 9 length(x) ## [1] 10 このベクトルがデータフレームから取り出したものである場合，そのデータフレームに NA を取り除いたベクトルを戻すことはできません。 行の対応関係が崩れるため当然ですが，勘違いしやすいので注意してください。 NA が含まれる計算結果は NA となるため，NA を取り除きたくなるかもしれません。 sum(x) ## [1] NA この場合，関数の引数に na.rm = TRUE を入れて，一時的に NA を取り除いて計算してください。 sum(x, na.rm = TRUE) ## [1] 51 この場合，x[!is.na(x)] のように，ベクトルからわざわざ NA を取り除く必要はありません。 判定の際に NA を取り除きたい場合は，次のようにします。 x[!is.na(x) &amp; x &gt; 5] ## [1] 7 10 9 6 8 4.1.1.2 論理積 &amp; は論理積と呼ばれるもので，英語の”and”，日本語の「かつ」という意味を持ち，判定の条件を増やすことを意味します。 NA に限らず，複数の比較演算を使いたい場合は，論理積 &amp; を使います。 もっと単純な例としては，以下のようなものがあります。 year[year &gt; 2000 &amp; year &lt; 2005] ## [1] 2001 2002 2003 2004 論理積は以下のベン図で表現できます。 4.1.1.3 論理和 複数の比較演算のいずれかが真となるという条件式を書きたい場合は，論理和 | を使います。 例えば，次のようにします。 year[year &gt; 2005 | year &lt; 1995] ## [1] 1990 1991 1992 1993 1994 2006 2007 2008 2009 2010 論理和は以下のベン図で表現できます。 このケースでは，2つの条件のどちらも満たす year は存在しませんので，実際には重なりはありません。 ここで，滅多に使わないですが，次の関係は知っておいてください。 TRUE &amp; NA ## [1] NA TRUE | NA ## [1] TRUE NA の取り扱いは難しいため，実際にコードを書くときには，コードを分解して，確実に意図通りの結果が得られていることを確かめながら，全体を完成させてください。 4.1.2 文字列 文字列の比較演算子が使えます。 文字列の比較演算は次のようにします。 prefecture &lt;- c(&quot;北海道&quot;, &quot;青森県&quot;, &quot;岩手県&quot;, &quot;宮城県&quot;, &quot;秋田県&quot;, &quot;山形県&quot;, &quot;福島県&quot;, &quot;茨城県&quot;, &quot;栃木県&quot;, &quot;群馬県&quot;, &quot;埼玉県&quot;, &quot;千葉県&quot;, &quot;東京都&quot;, &quot;神奈川県&quot;, &quot;新潟県&quot;, &quot;富山県&quot;, &quot;石川県&quot;, &quot;福井県&quot;, &quot;山梨県&quot;, &quot;長野県&quot;, &quot;岐阜県&quot;, &quot;静岡県&quot;, &quot;愛知県&quot;, &quot;三重県&quot;, &quot;滋賀県&quot;, &quot;京都府&quot;, &quot;大阪府&quot;, &quot;兵庫県&quot;, &quot;奈良県&quot;, &quot;和歌山県&quot;, &quot;鳥取県&quot;, &quot;島根県&quot;, &quot;岡山県&quot;, &quot;広島県&quot;, &quot;山口県&quot;, &quot;徳島県&quot;, &quot;香川県&quot;, &quot;愛媛県&quot;, &quot;高知県&quot;, &quot;福岡県&quot;, &quot;佐賀県&quot;, &quot;長崎県&quot;, &quot;熊本県&quot;, &quot;大分県&quot;, &quot;宮崎県&quot;, &quot;鹿児島県&quot;, &quot;沖縄県&quot;) prefecture[prefecture == &quot;愛媛県&quot;] ## [1] &quot;愛媛県&quot; 数値と同じく，文字列の返り値も論理値です。 文字列の場合，== は完全一致を意味します。 prefecture[prefecture == \"愛媛県\"] の例はあまり意味がありません。 しかし，prefecture == \"愛媛県\" の部分は重要です。 次のコマンドの返り値がどうなるかをよく知っておいてください。 prefecture == &quot;愛媛県&quot; ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [37] FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE 文字列の場合，大きさはないため，&gt; や &lt; といった比較演算子は使えないはずです。 prefecture[prefecture &gt; &quot;愛媛県&quot;] ## [1] &quot;北海道&quot; &quot;青森県&quot; &quot;岩手県&quot; &quot;宮城県&quot; &quot;秋田県&quot; &quot;山形県&quot; &quot;福島県&quot; ## [8] &quot;茨城県&quot; &quot;栃木県&quot; &quot;群馬県&quot; &quot;埼玉県&quot; &quot;千葉県&quot; &quot;東京都&quot; &quot;神奈川県&quot; ## [15] &quot;新潟県&quot; &quot;富山県&quot; &quot;石川県&quot; &quot;福井県&quot; &quot;山梨県&quot; &quot;長野県&quot; &quot;岐阜県&quot; ## [22] &quot;静岡県&quot; &quot;三重県&quot; &quot;滋賀県&quot; &quot;京都府&quot; &quot;大阪府&quot; &quot;兵庫県&quot; &quot;奈良県&quot; ## [29] &quot;和歌山県&quot; &quot;鳥取県&quot; &quot;島根県&quot; &quot;岡山県&quot; &quot;広島県&quot; &quot;山口県&quot; &quot;徳島県&quot; ## [36] &quot;香川県&quot; &quot;高知県&quot; &quot;福岡県&quot; &quot;佐賀県&quot; &quot;長崎県&quot; &quot;熊本県&quot; &quot;大分県&quot; ## [43] &quot;宮崎県&quot; &quot;鹿児島県&quot; &quot;沖縄県&quot; prefecture[prefecture &lt; &quot;愛媛県&quot;] ## [1] &quot;愛知県&quot; 予想に反して，返り値はエラーではありません。 これは，各文字列の文字コードを比較しています。 このことは，次のコマンドでも確認できます。 factor(prefecture) ## [1] 北海道 青森県 岩手県 宮城県 秋田県 山形県 福島県 茨城県 ## [9] 栃木県 群馬県 埼玉県 千葉県 東京都 神奈川県 新潟県 富山県 ## [17] 石川県 福井県 山梨県 長野県 岐阜県 静岡県 愛知県 三重県 ## [25] 滋賀県 京都府 大阪府 兵庫県 奈良県 和歌山県 鳥取県 島根県 ## [33] 岡山県 広島県 山口県 徳島県 香川県 愛媛県 高知県 福岡県 ## [41] 佐賀県 長崎県 熊本県 大分県 宮崎県 鹿児島県 沖縄県 ## 47 Levels: 愛知県 愛媛県 茨城県 岡山県 沖縄県 岩手県 岐阜県 宮崎県 ... 和歌山県 Levels がおかしな並び順になっていることが確認できます。 ここで R と RStudio では， levels(prefecture) が異なります。 なぜなのか？どなたか説明いただければ幸いです。RStudio は何をしているのでしょうか？ こうした文字コードでの順序づけを回避するには，levels() を明示的に指定しなければなりません。 (prefecture_factor &lt;- factor(prefecture, levels = prefecture, ordered = TRUE)) ## [1] 北海道 青森県 岩手県 宮城県 秋田県 山形県 福島県 茨城県 ## [9] 栃木県 群馬県 埼玉県 千葉県 東京都 神奈川県 新潟県 富山県 ## [17] 石川県 福井県 山梨県 長野県 岐阜県 静岡県 愛知県 三重県 ## [25] 滋賀県 京都府 大阪府 兵庫県 奈良県 和歌山県 鳥取県 島根県 ## [33] 岡山県 広島県 山口県 徳島県 香川県 愛媛県 高知県 福岡県 ## [41] 佐賀県 長崎県 熊本県 大分県 宮崎県 鹿児島県 沖縄県 ## 47 Levels: 北海道 &lt; 青森県 &lt; 岩手県 &lt; 宮城県 &lt; 秋田県 &lt; 山形県 &lt; ... &lt; 沖縄県 prefecture_factor[prefecture_factor &gt; &quot;愛媛県&quot;] ## [1] 高知県 福岡県 佐賀県 長崎県 熊本県 大分県 宮崎県 鹿児島県 ## [9] 沖縄県 ## 47 Levels: 北海道 &lt; 青森県 &lt; 岩手県 &lt; 宮城県 &lt; 秋田県 &lt; 山形県 &lt; ... &lt; 沖縄県 このようなこともできますが，特別な理由がない限り，文字列の大小比較はしないでください。 さて，文字列のベクトルの中から共通する要素を取り出したいことがあるかもしれません。 例えば，都道府県の中から府のみを取り出したいときに，次のようにしても得たい結果は得られません。 prefecture[prefecture == &quot;府&quot;] ## character(0) 上述のように，== は完全一致を意味するからです。 このとき，次のようにします。 prefecture[grep(&quot;府&quot;, prefecture)] ## [1] &quot;京都府&quot; &quot;大阪府&quot; これは正規表現を使った抽出です。 このコマンドはやや冗長で，本来なら次のようにすべきです。 grep(&quot;府&quot;, prefecture, value = TRUE) ## [1] &quot;京都府&quot; &quot;大阪府&quot; grep は正規表現を使った処理ができる関数のひとつです。 ただし，正規表現の理解は初学者には難しいでしょう。 4.1.3 正規表現 正規表現を知っているかどうかで，比較演算子の効率的な使い方が飛躍的に向上します。 正規表現は，人間が考えるかのようにコンピュータに考えさせる記述方法です。 しかし，非常にややこしいので，最初は覚える必要はありません。 Rをある程度使えるようになったら，以下のWebページを確認してください。 R における正規表現 - RjpWiki 4.1.4 集合 集合は次の関数で処理します。 union(x, y) intersect(x, y) setdiff(x, y) setequal(x, y) なぜか実践ではこれらの関数はほとんど使用されません。 ただし，%in% を使う機会が多いです。 例えば，インストールしていないパッケージ名を知りたいときは次のようにします。 installed &lt;- unname(installed.packages()[, &quot;Package&quot;]) available &lt;- rownames(available.packages()) uninstalled &lt;- setdiff(available, installed) この最後の1行は，次のようにするのが一般的です。 uninstalled &lt;- available[!available %in% installed] 4.2 条件分岐 条件分岐とは，「もし〜ならば」という条件「〜」を満たす場合に，指定の処理をする手続きのことです。 x &lt;- 1 if (x == 1) { print(&quot;正解です。&quot;) } ## [1] &quot;正解です。&quot; このように，if と () の間にスペースを入れます。 また，{} の前後は改行し，{} の中は左にインデントを付けるようにしてください。 インデントは，スペース2つが一般的です（スペースを4つ付ける人もいます）。 if 文は，「そうでなければ」ということを意味する else を伴うこともできます。 x &lt;- 1 if (x == 1) { print(&quot;正解です。&quot;) } else { print(&quot;不正解です。&quot;) } ## [1] &quot;正解です。&quot; x &lt;- sample(1:5) if (x[1] == 1) { print(&quot;正解です。&quot;) } else { print(&quot;不正解です。&quot;) } ## [1] &quot;不正解です。&quot; if 文の () の中は，長さ1のベクトル（スカラーではない）かつ論理値でなければなりません。 すなわち，if 文の () の中は TRUE か FALSE です。 もしベクトルの要素1つずつ処理したい場合は，次に説明する繰り返し処理と組み合わせて使います。 4.3 繰り返し処理 x &lt;- 1 for (i in 1:10) { x &lt;- x + 1 } x ## [1] 11 このように，for と () の間にスペースを入れます。 また，for 文と同じように，{} の前後は改行し，{} の中は左にインデントを付けるようにしてください。 for 文を使うときは，必ずループから抜け出せるようにしてください。 例えば，for の引数に {} の中で代入した場合，無限ループになることがあります。 繰り返し処理には，for 文意外に while 文もあります。 4.4 データ・クリーニング よく使う関数に次のようなものがある。 table() unique() order() apply() sapply() lapply() 例えば，次のように使う。 table(iris$Species) ## ## setosa versicolor virginica ## 50 50 50 unique(iris$Species) ## [1] setosa versicolor virginica ## Levels: setosa versicolor virginica order(iris$Sepal.Length, decreasing = TRUE) ## [1] 132 118 119 123 136 106 131 108 110 126 130 103 51 53 121 140 142 77 113 ## [20] 144 66 78 87 109 125 141 145 146 59 76 55 105 111 117 148 52 75 112 ## [39] 116 129 133 138 57 73 88 101 104 124 134 137 147 69 98 127 149 64 72 ## [58] 74 92 128 135 63 79 84 86 120 139 62 71 150 15 68 83 93 102 115 ## [77] 143 16 19 56 80 96 97 100 114 65 67 70 89 95 122 34 37 54 81 ## [96] 82 90 91 6 11 17 21 32 85 49 28 29 33 60 1 18 20 22 24 ## [115] 40 45 47 99 5 8 26 27 36 41 44 50 61 94 2 10 35 38 58 ## [134] 107 12 13 25 31 46 3 30 4 7 23 48 42 9 39 43 14 head(iris[order(iris$Sepal.Length, decreasing = TRUE), ]) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 132 7.9 3.8 6.4 2.0 virginica ## 118 7.7 3.8 6.7 2.2 virginica ## 119 7.7 2.6 6.9 2.3 virginica ## 123 7.7 2.8 6.7 2.0 virginica ## 136 7.7 3.0 6.1 2.3 virginica ## 106 7.6 3.0 6.6 2.1 virginica 論理式での数値は，0 のみが FALSE として扱われ，それ以外は TRUE として扱われます。 as.logical(1) ## [1] TRUE as.logical(0) ## [1] FALSE 4.5 関数の作成 関数を自分で作ることができます。 x &lt;- function (y) { paste(y, collapse = &quot;/&quot;) } x(c(&quot;Apple&quot;, &quot;Orange&quot;)) ## [1] &quot;Apple/Orange&quot; 4.6 練習問題 次のデータフレーム z があるとする。z を使って，2000年以降の value の値の平均を求めなさい。基礎の練習問題と同じです。ただし，ここでは比較演算子を用いなさい。 x &lt;- 1990:2021 y &lt;- seq(5000, 5030, 2) z &lt;- data.frame(year = x, value = y) 九九（1から9までの整数同士の掛け算）のすべての組み合わせの答えを合計しなさい。 「北海道」「青森」…「東京」…といった都道府県のベクトル pref があります。北海道には「道」の文字が付いていますが，都府県には「都」「府」「県」の文字が付いていません。そこで，都府県にも「都府県」を付けて，すべてのデータが「都道府県」で終わるように揃えたいとします。ただし，データの中には47都道府県がすべて含まれているかどうか，重複があるかどうかは分かりません。すべての文字列が「都道府県」で終わるように揃えなさい。 ポケモンの中から，water タイプのポケモンをすべて挙げなさい。 ただし，ポケモンのデータセットは，d3po パッケージの pokemon を使いなさい。 "],["5-作図.html", "5 作図 5.1 どんな図を作成できるのか 5.2 プロット 5.3 保存", " 5 作図 Rの得意な作業のひとつが作図です。 5.1 どんな図を作成できるのか Rには最初から関数やパッケージの使用例があります。 example(plot) ## ## plot&gt; Speed &lt;- cars$speed ## ## plot&gt; Distance &lt;- cars$dist ## ## plot&gt; plot(Speed, Distance, panel.first = grid(8, 8), ## plot+ pch = 0, cex = 1.2, col = &quot;blue&quot;) ## ## plot&gt; plot(Speed, Distance, ## plot+ panel.first = lines(stats::lowess(Speed, Distance), lty = &quot;dashed&quot;), ## plot+ pch = 0, cex = 1.2, col = &quot;blue&quot;) ## ## plot&gt; ## Show the different plot types ## plot&gt; x &lt;- 0:12 ## ## plot&gt; y &lt;- sin(pi/5 * x) ## ## plot&gt; op &lt;- par(mfrow = c(3,3), mar = .1+ c(2,2,3,1)) ## ## plot&gt; for (tp in c(&quot;p&quot;,&quot;l&quot;,&quot;b&quot;, &quot;c&quot;,&quot;o&quot;,&quot;h&quot;, &quot;s&quot;,&quot;S&quot;,&quot;n&quot;)) { ## plot+ plot(y ~ x, type = tp, main = paste0(&quot;plot(*, type = \\&quot;&quot;, tp, &quot;\\&quot;)&quot;)) ## plot+ if(tp == &quot;S&quot;) { ## plot+ lines(x, y, type = &quot;s&quot;, col = &quot;red&quot;, lty = 2) ## plot+ mtext(&quot;lines(*, type = \\&quot;s\\&quot;, ...)&quot;, col = &quot;red&quot;, cex = 0.8) ## plot+ } ## plot+ } ## ## plot&gt; par(op) ## ## plot&gt; ##--- Log-Log Plot with custom axes ## plot&gt; lx &lt;- seq(1, 5, length.out = 41) ## ## plot&gt; yl &lt;- expression(e^{-frac(1,2) * {log[10](x)}^2}) ## ## plot&gt; y &lt;- exp(-.5*lx^2) ## ## plot&gt; op &lt;- par(mfrow = c(2,1), mar = par(&quot;mar&quot;)-c(1,0,2,0), mgp = c(2, .7, 0)) ## ## plot&gt; plot(10^lx, y, log = &quot;xy&quot;, type = &quot;l&quot;, col = &quot;purple&quot;, ## plot+ main = &quot;Log-Log plot&quot;, ylab = yl, xlab = &quot;x&quot;) ## ## plot&gt; plot(10^lx, y, log = &quot;xy&quot;, type = &quot;o&quot;, pch = &quot;.&quot;, col = &quot;forestgreen&quot;, ## plot+ main = &quot;Log-Log plot with custom axes&quot;, ylab = yl, xlab = &quot;x&quot;, ## plot+ axes = FALSE, frame.plot = TRUE) ## ## plot&gt; my.at &lt;- 10^(1:5) ## ## plot&gt; axis(1, at = my.at, labels = formatC(my.at, format = &quot;fg&quot;)) ## ## plot&gt; e.y &lt;- -5:-1 ; at.y &lt;- 10^e.y ## ## plot&gt; axis(2, at = at.y, col.axis = &quot;red&quot;, las = 1, ## plot+ labels = as.expression(lapply(e.y, function(E) bquote(10^.(E))))) ## ## plot&gt; par(op) Enterキー または Returnキー を押すと次々と図が表示されます。 同時に，コンソールには，作図に用いたコードが表示されます。 demo(graphics) ## ## ## demo(graphics) ## ---- ~~~~~~~~ ## ## &gt; # Copyright (C) 1997-2009 The R Core Team ## &gt; ## &gt; require(datasets) ## ## &gt; require(grDevices); require(graphics) ## ## &gt; ## Here is some code which illustrates some of the differences between ## &gt; ## R and S graphics capabilities. Note that colors are generally specified ## &gt; ## by a character string name (taken from the X11 rgb.txt file) and that line ## &gt; ## textures are given similarly. The parameter &quot;bg&quot; sets the background ## &gt; ## parameter for the plot and there is also an &quot;fg&quot; parameter which sets ## &gt; ## the foreground color. ## &gt; ## &gt; ## &gt; x &lt;- stats::rnorm(50) ## ## &gt; opar &lt;- par(bg = &quot;white&quot;) ## ## &gt; plot(x, ann = FALSE, type = &quot;n&quot;) ## ## &gt; abline(h = 0, col = gray(.90)) ## ## &gt; lines(x, col = &quot;green4&quot;, lty = &quot;dotted&quot;) ## ## &gt; points(x, bg = &quot;limegreen&quot;, pch = 21) ## ## &gt; title(main = &quot;Simple Use of Color In a Plot&quot;, ## + xlab = &quot;Just a Whisper of a Label&quot;, ## + col.main = &quot;blue&quot;, col.lab = gray(.8), ## + cex.main = 1.2, cex.lab = 1.0, font.main = 4, font.lab = 3) ## ## &gt; ## A little color wheel. This code just plots equally spaced hues in ## &gt; ## a pie chart. If you have a cheap SVGA monitor (like me) you will ## &gt; ## probably find that numerically equispaced does not mean visually ## &gt; ## equispaced. On my display at home, these colors tend to cluster at ## &gt; ## the RGB primaries. On the other hand on the SGI Indy at work the ## &gt; ## effect is near perfect. ## &gt; ## &gt; par(bg = &quot;gray&quot;) ## ## &gt; pie(rep(1,24), col = rainbow(24), radius = 0.9) ## ## &gt; title(main = &quot;A Sample Color Wheel&quot;, cex.main = 1.4, font.main = 3) ## ## &gt; title(xlab = &quot;(Use this as a test of monitor linearity)&quot;, ## + cex.lab = 0.8, font.lab = 3) ## ## &gt; ## We have already confessed to having these. This is just showing off X11 ## &gt; ## color names (and the example (from the postscript manual) is pretty &quot;cute&quot;. ## &gt; ## &gt; pie.sales &lt;- c(0.12, 0.3, 0.26, 0.16, 0.04, 0.12) ## ## &gt; names(pie.sales) &lt;- c(&quot;Blueberry&quot;, &quot;Cherry&quot;, ## + &quot;Apple&quot;, &quot;Boston Cream&quot;, &quot;Other&quot;, &quot;Vanilla Cream&quot;) ## ## &gt; pie(pie.sales, ## + col = c(&quot;purple&quot;,&quot;violetred1&quot;,&quot;green3&quot;,&quot;cornsilk&quot;,&quot;cyan&quot;,&quot;white&quot;)) ## ## &gt; title(main = &quot;January Pie Sales&quot;, cex.main = 1.8, font.main = 1) ## ## &gt; title(xlab = &quot;(Don&#39;t try this at home kids)&quot;, cex.lab = 0.8, font.lab = 3) ## ## &gt; ## Boxplots: I couldn&#39;t resist the capability for filling the &quot;box&quot;. ## &gt; ## The use of color seems like a useful addition, it focuses attention ## &gt; ## on the central bulk of the data. ## &gt; ## &gt; par(bg=&quot;cornsilk&quot;) ## ## &gt; n &lt;- 10 ## ## &gt; g &lt;- gl(n, 100, n*100) ## ## &gt; x &lt;- rnorm(n*100) + sqrt(as.numeric(g)) ## ## &gt; boxplot(split(x,g), col=&quot;lavender&quot;, notch=TRUE) ## ## &gt; title(main=&quot;Notched Boxplots&quot;, xlab=&quot;Group&quot;, font.main=4, font.lab=1) ## ## &gt; ## An example showing how to fill between curves. ## &gt; ## &gt; par(bg=&quot;white&quot;) ## ## &gt; n &lt;- 100 ## ## &gt; x &lt;- c(0,cumsum(rnorm(n))) ## ## &gt; y &lt;- c(0,cumsum(rnorm(n))) ## ## &gt; xx &lt;- c(0:n, n:0) ## ## &gt; yy &lt;- c(x, rev(y)) ## ## &gt; plot(xx, yy, type=&quot;n&quot;, xlab=&quot;Time&quot;, ylab=&quot;Distance&quot;) ## ## &gt; polygon(xx, yy, col=&quot;gray&quot;) ## ## &gt; title(&quot;Distance Between Brownian Motions&quot;) ## ## &gt; ## Colored plot margins, axis labels and titles. You do need to be ## &gt; ## careful with these kinds of effects. It&#39;s easy to go completely ## &gt; ## over the top and you can end up with your lunch all over the keyboard. ## &gt; ## On the other hand, my market research clients love it. ## &gt; ## &gt; x &lt;- c(0.00, 0.40, 0.86, 0.85, 0.69, 0.48, 0.54, 1.09, 1.11, 1.73, 2.05, 2.02) ## ## &gt; par(bg=&quot;lightgray&quot;) ## ## &gt; plot(x, type=&quot;n&quot;, axes=FALSE, ann=FALSE) ## ## &gt; usr &lt;- par(&quot;usr&quot;) ## ## &gt; rect(usr[1], usr[3], usr[2], usr[4], col=&quot;cornsilk&quot;, border=&quot;black&quot;) ## ## &gt; lines(x, col=&quot;blue&quot;) ## ## &gt; points(x, pch=21, bg=&quot;lightcyan&quot;, cex=1.25) ## ## &gt; axis(2, col.axis=&quot;blue&quot;, las=1) ## ## &gt; axis(1, at=1:12, lab=month.abb, col.axis=&quot;blue&quot;) ## ## &gt; box() ## ## &gt; title(main= &quot;The Level of Interest in R&quot;, font.main=4, col.main=&quot;red&quot;) ## ## &gt; title(xlab= &quot;1996&quot;, col.lab=&quot;red&quot;) ## ## &gt; ## A filled histogram, showing how to change the font used for the ## &gt; ## main title without changing the other annotation. ## &gt; ## &gt; par(bg=&quot;cornsilk&quot;) ## ## &gt; x &lt;- rnorm(1000) ## ## &gt; hist(x, xlim=range(-4, 4, x), col=&quot;lavender&quot;, main=&quot;&quot;) ## ## &gt; title(main=&quot;1000 Normal Random Variates&quot;, font.main=3) ## ## &gt; ## A scatterplot matrix ## &gt; ## The good old Iris data (yet again) ## &gt; ## &gt; pairs(iris[1:4], main=&quot;Edgar Anderson&#39;s Iris Data&quot;, font.main=4, pch=19) ## ## &gt; pairs(iris[1:4], main=&quot;Edgar Anderson&#39;s Iris Data&quot;, pch=21, ## + bg = c(&quot;red&quot;, &quot;green3&quot;, &quot;blue&quot;)[unclass(iris$Species)]) ## ## &gt; ## Contour plotting ## &gt; ## This produces a topographic map of one of Auckland&#39;s many volcanic &quot;peaks&quot;. ## &gt; ## &gt; x &lt;- 10*1:nrow(volcano) ## ## &gt; y &lt;- 10*1:ncol(volcano) ## ## &gt; lev &lt;- pretty(range(volcano), 10) ## ## &gt; par(bg = &quot;lightcyan&quot;) ## ## &gt; pin &lt;- par(&quot;pin&quot;) ## ## &gt; xdelta &lt;- diff(range(x)) ## ## &gt; ydelta &lt;- diff(range(y)) ## ## &gt; xscale &lt;- pin[1]/xdelta ## ## &gt; yscale &lt;- pin[2]/ydelta ## ## &gt; scale &lt;- min(xscale, yscale) ## ## &gt; xadd &lt;- 0.5*(pin[1]/scale - xdelta) ## ## &gt; yadd &lt;- 0.5*(pin[2]/scale - ydelta) ## ## &gt; plot(numeric(0), numeric(0), ## + xlim = range(x)+c(-1,1)*xadd, ylim = range(y)+c(-1,1)*yadd, ## + type = &quot;n&quot;, ann = FALSE) ## ## &gt; usr &lt;- par(&quot;usr&quot;) ## ## &gt; rect(usr[1], usr[3], usr[2], usr[4], col=&quot;green3&quot;) ## ## &gt; contour(x, y, volcano, levels = lev, col=&quot;yellow&quot;, lty=&quot;solid&quot;, add=TRUE) ## ## &gt; box() ## ## &gt; title(&quot;A Topographic Map of Maunga Whau&quot;, font= 4) ## ## &gt; title(xlab = &quot;Meters North&quot;, ylab = &quot;Meters West&quot;, font= 3) ## ## &gt; mtext(&quot;10 Meter Contour Spacing&quot;, side=3, line=0.35, outer=FALSE, ## + at = mean(par(&quot;usr&quot;)[1:2]), cex=0.7, font=3) ## ## &gt; ## Conditioning plots ## &gt; ## &gt; par(bg=&quot;cornsilk&quot;) ## ## &gt; coplot(lat ~ long | depth, data = quakes, pch = 21, bg = &quot;green3&quot;) ## ## &gt; par(opar) demo(image) ## ## ## demo(image) ## ---- ~~~~~ ## ## &gt; # Copyright (C) 1997-2009 The R Core Team ## &gt; ## &gt; require(datasets) ## ## &gt; require(grDevices); require(graphics) ## ## &gt; x &lt;- 10*(1:nrow(volcano)); x.at &lt;- seq(100, 800, by=100) ## ## &gt; y &lt;- 10*(1:ncol(volcano)); y.at &lt;- seq(100, 600, by=100) ## ## &gt; # Using Terrain Colors ## &gt; ## &gt; image(x, y, volcano, col=terrain.colors(100),axes=FALSE) ## ## &gt; contour(x, y, volcano, levels=seq(90, 200, by=5), add=TRUE, col=&quot;brown&quot;) ## ## &gt; axis(1, at=x.at) ## ## &gt; axis(2, at=y.at) ## ## &gt; box() ## ## &gt; title(main=&quot;Maunga Whau Volcano&quot;, sub = &quot;col=terrain.colors(100)&quot;, font.main=4) ## ## &gt; # Using Heat Colors ## &gt; ## &gt; image(x, y, volcano, col=heat.colors(100), axes=FALSE) ## ## &gt; contour(x, y, volcano, levels=seq(90, 200, by=5), add=TRUE, col=&quot;brown&quot;) ## ## &gt; axis(1, at=x.at) ## ## &gt; axis(2, at=y.at) ## ## &gt; box() ## ## &gt; title(main=&quot;Maunga Whau Volcano&quot;, sub = &quot;col=heat.colors(100)&quot;, font.main=4) ## ## &gt; # Using Gray Scale ## &gt; ## &gt; image(x, y, volcano, col=gray(100:200/200), axes=FALSE) ## ## &gt; contour(x, y, volcano, levels=seq(90, 200, by=5), add=TRUE, col=&quot;black&quot;) ## ## &gt; axis(1, at=x.at) ## ## &gt; axis(2, at=y.at) ## ## &gt; box() ## ## &gt; title(main=&quot;Maunga Whau Volcano \\n col=gray(100:200/200)&quot;, font.main=4) ## ## &gt; ## Filled Contours are even nicer sometimes : ## &gt; example(filled.contour) ## ## flld.c&gt; require(&quot;grDevices&quot;) # for colours ## ## flld.c&gt; filled.contour(volcano, asp = 1) # simple ## ## flld.c&gt; x &lt;- 10*1:nrow(volcano) ## ## flld.c&gt; y &lt;- 10*1:ncol(volcano) ## ## flld.c&gt; filled.contour(x, y, volcano, ## flld.c+ color.palette = function(n) hcl.colors(n, &quot;terrain&quot;), ## flld.c+ plot.title = title(main = &quot;The Topography of Maunga Whau&quot;, ## flld.c+ xlab = &quot;Meters North&quot;, ylab = &quot;Meters West&quot;), ## flld.c+ plot.axes = { axis(1, seq(100, 800, by = 100)) ## flld.c+ axis(2, seq(100, 600, by = 100)) }, ## flld.c+ key.title = title(main = &quot;Height\\n(meters)&quot;), ## flld.c+ key.axes = axis(4, seq(90, 190, by = 10))) # maybe also asp = 1 ## ## flld.c&gt; mtext(paste(&quot;filled.contour(.) from&quot;, R.version.string), ## flld.c+ side = 1, line = 4, adj = 1, cex = .66) ## ## flld.c&gt; # Annotating a filled contour plot ## flld.c&gt; a &lt;- expand.grid(1:20, 1:20) ## ## flld.c&gt; b &lt;- matrix(a[,1] + a[,2], 20) ## ## flld.c&gt; filled.contour(x = 1:20, y = 1:20, z = b, ## flld.c+ plot.axes = { axis(1); axis(2); points(10, 10) }) ## ## flld.c&gt; ## Persian Rug Art: ## flld.c&gt; x &lt;- y &lt;- seq(-4*pi, 4*pi, length.out = 27) ## ## flld.c&gt; r &lt;- sqrt(outer(x^2, y^2, `+`)) ## ## flld.c&gt; ## &quot;minimal&quot; ## flld.c&gt; filled.contour(cos(r^2)*exp(-r/(2*pi)), axes = FALSE, key.border=NA) ## ## flld.c&gt; ## rather, the key *should* be labeled (but axes still not): ## flld.c&gt; filled.contour(cos(r^2)*exp(-r/(2*pi)), frame.plot = FALSE, ## flld.c+ plot.axes = {}) # demo(persp) # demo(colors) # demo(lm.glm) # demo(nlm) # demo(smooth) 次のコマンドにより，デモの一覧を見ることができる。 demo() 5.2 プロット さっそく，プロットしてみよう。 plot(x) hist(x) 作図ウィンドウを明示的に閉じる場合，次のようにします。 def.off() 5.3 保存 PDF，PNG，SVGのいずれかの形式でファイルに保存するのが一般的です。 書くのが面倒なので，書かないかもしれません。 "],["6-tidyverse.html", "6 tidyverse 6.1 base R 6.2 tidyverse 6.3 練習問題", " 6 tidyverse これまでは base R を使ってきました。 近年，Rの中でも tidyverse を使うケースが一般的になりました。 base R は伝統的な R の使い方で，R 3.x あたりで tidyverse が登場しました。 tidyverse が登場した後，これまでの伝統的な R のコードは base R と呼ばれるようになりました。 それでは，base R とは何でしょうか，tidyverse とは何でしょうか。 これらを説明するのはやや難しいです。 しかし，感覚的な違いがありますので，この感覚を身に付けることを目指しましょう。 ここでは，base R と tidyverse の違いについて，実践的に学びます。 6.1 base R まず，次のようなデータがあるとします。 year &lt;- 1990:2025 x1 &lt;- 100 * 1:length(year) x2 &lt;- 100 * length(year):1 df &lt;- data.frame(year = year, 南 = x1, 北 = x2) このデータフレーム df の中から2000年代以降のデータを取り出して，南 列の平均を計算する場合，次のようなコードになります。 minami2000 &lt;- df[df$year &gt;= 2000, &quot;南&quot;] mean(minami2000) ## [1] 2350 また，同じことは次のようにしても実行できます。 minami2000 &lt;- df$南[df$year &gt;= 2000] mean(minami2000) ## [1] 2350 もしこの後に，北 列の合計を計算したい場合は，次のようなコードにした方がいいかもしれません。 df2000 &lt;- df[df$year &gt;= 2000, ] mean(df2000$南) ## [1] 2350 sum(df2000$北) ## [1] 35100 上に示したコードのいずれにも共通するのが，新たな変数を作成している点です。 コードを書くようになると，作業途中に必要な変数の名前を考えるのが面倒になってきます。 こうした変数が少ない場合は特に問題となりませんが，多くなってくると意味のある変数名がなかなか思い浮かびません。 どうすればよいか正解があるわけではないし，いちいち考えるのが面倒なので，tmp とか df2 や df3 といった変数名にしがちですが，どの場合も後々に見て意味がわかりにくいです。 そこで，例えば，次のようにすることもあります。 mean(df[df$year &gt;= 2000, &quot;南&quot;]) ## [1] 2350 sum(df[df$year &gt;= 2000, &quot;北&quot;]) ## [1] 35100 ただし，これらのコードの問題は，人間が見てわかりにくいということです。 これは，右から左に解釈していくためです。 右から左ではなく，左から右に処理が進む方が人間（日本語や英語話者）にとって理解しやすいです。 そこで，他の多くの言語にあるパイプ演算子の機能が R にも備わるようになりました。 6.2 tidyverse パイプ演算 %&gt;% は magrittr パッケージをロードすると使えるようになります。 library(magrittr) library(dplyr) df %&gt;% filter(year &gt;= 2000) %&gt;% pull(南) %&gt;% mean() ## [1] 2350 filter() と pull() は dplyr パッケージの関数です。 パイプ演算子があまりにも便利なため，R は 4.1.0 で公式にパイプ演算子を採用しました。 R 公式のパイプ演算子は |&gt; です。 df |&gt; filter(year &gt;= 2000) |&gt; pull(南) |&gt; mean() ## [1] 2350 %&gt;% と |&gt; はどちらを使っても同じ場合が多いですが，%&gt;% の方が機能が多いため，完全に同じではありません。 大きな違いはプレイスホルダー . の扱いです。 置き換え可能な場合は，|&gt; を使うことをおすすめします。 パイプ演算子は base R の関数と組み合わせて使うことができます。 df |&gt; filter(year &gt;= 2000) |&gt; head() ## year 南 北 ## 1 2000 1100 2600 ## 2 2001 1200 2500 ## 3 2002 1300 2400 ## 4 2003 1400 2300 ## 5 2004 1500 2200 ## 6 2005 1600 2100 パイプ演算子を使うと，その前のデータが次に書く関数の最初の引数として自動的に渡されます。 この文章の意味が理解できるまで，知っている関数をいろいろ使ってみてください。 処理結果を新しい変数に代入する場合は，base R の作法に従います。 df2000 &lt;- df |&gt; filter(year &gt;= 2000) ちなみに，次のようにすることもできますが，このようなコードはあまり見ません。 df |&gt; filter(year &gt;= 2000) -&gt; df2000 tidyverse とは dplyr のような，パイプ演算子を使うことを前提に考えられた（正確には少し違う）パッケージ群のことです。 tidyverse を構成するパッケージはここ で確認できます。 6.2.1 データフレーム tidyverse で使われるデータフレームは tibble です。 普通のデータフレームと tibble は互換性がありますので，特に意識する必要はありません。 どちらもデータフレームと呼びます。 ただし，データフレームの形には，ワイドとロングがあり，これらの違いを意識する必要があります。 ワイドはMicrosoft Excelでよく見る，複数の列がある表のようなデータフレームのことです。 一方，ロングは縦に長いデータフレームです。 ロングとワイドは tidyr の関数を使って簡単に変換することができます。 まず，ワイドは次のようなデータフレームです。 head(df) ## year 南 北 ## 1 1990 100 3600 ## 2 1991 200 3500 ## 3 1992 300 3400 ## 4 1993 400 3300 ## 5 1994 500 3200 ## 6 1995 600 3100 dim(df) ## [1] 36 3 これをロングに変換すると次のようなデータフレームになります。 df_long &lt;- tidyr::pivot_longer(df, cols = -year) df_long ## # A tibble: 72 × 3 ## year name value ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1990 南 100 ## 2 1990 北 3600 ## 3 1991 南 200 ## 4 1991 北 3500 ## 5 1992 南 300 ## 6 1992 北 3400 ## 7 1993 南 400 ## 8 1993 北 3300 ## 9 1994 南 500 ## 10 1994 北 3200 ## # ℹ 62 more rows tidyverse で作成したデータフレームは tibble になります。 tibble の便利な点は，head() や dim() をわざわざ実行しなくても，データフレームの概要がわかります。 また，ggplot2 パッケージの ggplot() で図を描く場合，ロングの方がデータを扱いやすいです。 一方，lm() などの回帰分析にはワイドのデータが向いています。 先ほどの変換は次のようにしても同じです。 df_long &lt;- tidyr::pivot_longer(df, cols = c(&quot;南&quot;, &quot;北&quot;)) df_long &lt;- tidyr::pivot_longer(df, cols = 南:北) ロングからワイドへの変換は次のようにします。 df_wide &lt;- tidyr::pivot_wider(df_long, names_from = name) df_wide ## # A tibble: 36 × 3 ## year 南 北 ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1990 100 3600 ## 2 1991 200 3500 ## 3 1992 300 3400 ## 4 1993 400 3300 ## 5 1994 500 3200 ## 6 1995 600 3100 ## 7 1996 700 3000 ## 8 1997 800 2900 ## 9 1998 900 2800 ## 10 1999 1000 2700 ## # ℹ 26 more rows なお，Google検索したり，古い文献を見ると，ロングとワイドの変換に tidyr::spread() と tidyr::gather() を使用しているケースがあります。 これらの関数は superseded になっています。 古い関数ですので，覚える必要はありません。 6.2.2 よく使う関数 次に iris を使って base R と tidyverse の違いを確認しておきます。 以下では名前空間（dplyr:: の部分）をわざわざ書いていますが，実際にコードを書くときは書かなくてもよいです。 6.2.2.1 filter() filter() で条件を満たす列を抽出します。 iris[iris$Sepal.Length &gt; 7, ] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 103 7.1 3.0 5.9 2.1 virginica ## 106 7.6 3.0 6.6 2.1 virginica ## 108 7.3 2.9 6.3 1.8 virginica ## 110 7.2 3.6 6.1 2.5 virginica ## 118 7.7 3.8 6.7 2.2 virginica ## 119 7.7 2.6 6.9 2.3 virginica ## 123 7.7 2.8 6.7 2.0 virginica ## 126 7.2 3.2 6.0 1.8 virginica ## 130 7.2 3.0 5.8 1.6 virginica ## 131 7.4 2.8 6.1 1.9 virginica ## 132 7.9 3.8 6.4 2.0 virginica ## 136 7.7 3.0 6.1 2.3 virginica iris |&gt; dplyr::filter(Sepal.Length &gt; 7) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 7.1 3.0 5.9 2.1 virginica ## 2 7.6 3.0 6.6 2.1 virginica ## 3 7.3 2.9 6.3 1.8 virginica ## 4 7.2 3.6 6.1 2.5 virginica ## 5 7.7 3.8 6.7 2.2 virginica ## 6 7.7 2.6 6.9 2.3 virginica ## 7 7.7 2.8 6.7 2.0 virginica ## 8 7.2 3.2 6.0 1.8 virginica ## 9 7.2 3.0 5.8 1.6 virginica ## 10 7.4 2.8 6.1 1.9 virginica ## 11 7.9 3.8 6.4 2.0 virginica ## 12 7.7 3.0 6.1 2.3 virginica head(iris[iris$Species == &quot;setosa&quot;, ]) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa iris |&gt; dplyr::filter(Species == &quot;setosa&quot;) |&gt; head() ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa tidyverse が常にわかりやすいとは限りません。 例えば，次の2つのコードを比較してみてください。 head(iris[iris$Sepal.Length &gt; mean(iris$Sepal.Length), ]) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 51 7.0 3.2 4.7 1.4 versicolor ## 52 6.4 3.2 4.5 1.5 versicolor ## 53 6.9 3.1 4.9 1.5 versicolor ## 55 6.5 2.8 4.6 1.5 versicolor ## 57 6.3 3.3 4.7 1.6 versicolor ## 59 6.6 2.9 4.6 1.3 versicolor iris |&gt; dplyr::filter(Sepal.Length &gt; iris |&gt; dplyr::summarise(mean_length = mean(Sepal.Length)) |&gt; dplyr::pull(mean_length)) |&gt; head() ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 7.0 3.2 4.7 1.4 versicolor ## 2 6.4 3.2 4.5 1.5 versicolor ## 3 6.9 3.1 4.9 1.5 versicolor ## 4 6.5 2.8 4.6 1.5 versicolor ## 5 6.3 3.3 4.7 1.6 versicolor ## 6 6.6 2.9 4.6 1.3 versicolor 後者のようなコードを書きたい場合は，次のように，tidyverse と base R を組み合わせるのがよいでしょう。 iris |&gt; dplyr::filter(Sepal.Length &gt; mean(Sepal.Length)) |&gt; head() ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 7.0 3.2 4.7 1.4 versicolor ## 2 6.4 3.2 4.5 1.5 versicolor ## 3 6.9 3.1 4.9 1.5 versicolor ## 4 6.5 2.8 4.6 1.5 versicolor ## 5 6.3 3.3 4.7 1.6 versicolor ## 6 6.6 2.9 4.6 1.3 versicolor 6.2.2.2 select() select() で必要な列のみを取り出します。 head(iris[&quot;Species&quot;]) ## Species ## 1 setosa ## 2 setosa ## 3 setosa ## 4 setosa ## 5 setosa ## 6 setosa iris |&gt; dplyr::select(Species) |&gt; head() ## Species ## 1 setosa ## 2 setosa ## 3 setosa ## 4 setosa ## 5 setosa ## 6 setosa 6.2.2.3 pull() 列をベクトルで取り出したい場合は，pull() を使います。 head(iris$Species) ## [1] setosa setosa setosa setosa setosa setosa ## Levels: setosa versicolor virginica iris |&gt; dplyr::pull(Species) |&gt; head() ## [1] setosa setosa setosa setosa setosa setosa ## Levels: setosa versicolor virginica 6.2.2.4 mutate() mutate() で新しい列を作成します。 その前に，iris を変更したくないので，iris のコピーを作成して，それをいじることにします。 iris2 &lt;- iris iris2$new_species &lt;- iris2$Species head(iris2) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species new_species ## 1 5.1 3.5 1.4 0.2 setosa setosa ## 2 4.9 3.0 1.4 0.2 setosa setosa ## 3 4.7 3.2 1.3 0.2 setosa setosa ## 4 4.6 3.1 1.5 0.2 setosa setosa ## 5 5.0 3.6 1.4 0.2 setosa setosa ## 6 5.4 3.9 1.7 0.4 setosa setosa iris |&gt; dplyr::mutate(new_species = Species) |&gt; head() ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species new_species ## 1 5.1 3.5 1.4 0.2 setosa setosa ## 2 4.9 3.0 1.4 0.2 setosa setosa ## 3 4.7 3.2 1.3 0.2 setosa setosa ## 4 4.6 3.1 1.5 0.2 setosa setosa ## 5 5.0 3.6 1.4 0.2 setosa setosa ## 6 5.4 3.9 1.7 0.4 setosa setosa また，既存の列を修正するのにも mutate() を使用します。 iris2$Sepal.Length &lt;- iris2$Sepal.Length * 100 head(iris2) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species new_species ## 1 510 3.5 1.4 0.2 setosa setosa ## 2 490 3.0 1.4 0.2 setosa setosa ## 3 470 3.2 1.3 0.2 setosa setosa ## 4 460 3.1 1.5 0.2 setosa setosa ## 5 500 3.6 1.4 0.2 setosa setosa ## 6 540 3.9 1.7 0.4 setosa setosa iris |&gt; dplyr::mutate(Sepal.Length = Sepal.Length * 100) |&gt; head() ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 510 3.5 1.4 0.2 setosa ## 2 490 3.0 1.4 0.2 setosa ## 3 470 3.2 1.3 0.2 setosa ## 4 460 3.1 1.5 0.2 setosa ## 5 500 3.6 1.4 0.2 setosa ## 6 540 3.9 1.7 0.4 setosa 6.2.2.5 count() table(iris$Species) ## ## setosa versicolor virginica ## 50 50 50 iris |&gt; dplyr::count(Species) ## Species n ## 1 setosa 50 ## 2 versicolor 50 ## 3 virginica 50 6.2.2.6 arrange() iris2 &lt;- iris[order(iris$Sepal.Length, decreasing = TRUE), ] head(iris2) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 132 7.9 3.8 6.4 2.0 virginica ## 118 7.7 3.8 6.7 2.2 virginica ## 119 7.7 2.6 6.9 2.3 virginica ## 123 7.7 2.8 6.7 2.0 virginica ## 136 7.7 3.0 6.1 2.3 virginica ## 106 7.6 3.0 6.6 2.1 virginica iris |&gt; dplyr::arrange(dplyr::desc(Sepal.Length)) |&gt; head() ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 7.9 3.8 6.4 2.0 virginica ## 2 7.7 3.8 6.7 2.2 virginica ## 3 7.7 2.6 6.9 2.3 virginica ## 4 7.7 2.8 6.7 2.0 virginica ## 5 7.7 3.0 6.1 2.3 virginica ## 6 7.6 3.0 6.6 2.1 virginica 6.2.2.7 summarise() sapply(split(iris$Sepal.Length, iris$Species), mean) ## setosa versicolor virginica ## 5.006 5.936 6.588 iris |&gt; dplyr::summarize(value = mean(Sepal.Length), .by = Species) ## Species value ## 1 setosa 5.006 ## 2 versicolor 5.936 ## 3 virginica 6.588 6.2.3 どちらを使えばよいのか base R と tidyverse の違いがわかったところで，次に考えるべきは「どちらを使うべきか」という問題です。 結論から言えば，「自分にとって使いやすい方を選ぶ」のが適切です。 ここで「使いやすい」という言葉には，次の2つの側面が含まれています。 自分がコードを理解しやすいこと。 他人がコードを理解しやすいこと。 個人的な印象として，tidyverse は操作が直感的で，コードが簡潔かつ読みやすくなることが多いです。 一方で，常に最適とは限りません。 例えば、map() 関数を使用するケースでは，base R で書いた方がわかりやすくなることもあります。 コードの可読性には重要な意味があります。 理解しにくいコードはバグが発生しやすくなる一方で，可読性の高いコードは必ずしも処理速度が最速ではない場合があります。 このトレードオフを考慮して選択する必要があります。 また，個人的な感覚としては，tidyverse は柔軟性が高くモダンなイメージがあり，base R には伝統的で安定感のあるイメージがあります。 ただし，いずれを選ぶ場合でも，冗長で無駄の多いコードは避けるべきです。 効率的で簡潔な記述を心がけることが大切です。 6.3 練習問題 次のデータフレーム z があるとする。z を使って，2000年以降の value の値の平均を求めなさい。ただし，ここでは tidyverse を用いなさい。 x &lt;- 1990:2021 y &lt;- seq(5000, 5030, 2) z &lt;- data.frame(year = x, value = y) ポケモンの中から，tidyverse を用いて，water タイプのポケモンをすべて挙げなさい。 ただし，ポケモンのデータセットは，d3po パッケージの pokemon を使いなさい。 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
